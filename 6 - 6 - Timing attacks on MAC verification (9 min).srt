1
00:00:00,000 --> 00:00:03,757
本章最后一节，我想为大家展示一个通用攻击
In the last segment in this module, I
wanna show you a general attack that

2
00:00:03,757 --> 00:00:07,615
它影响了许多MAC算法的实现
affects many implementations of MAC
algorithms. And there's a nice lesson to

3
00:00:07,615 --> 00:00:11,727
这种攻击给了我们很好的教训。我们看一个
be learned from an attack like this. So
let's look at a particular implementation

4
00:00:11,727 --> 00:00:15,941
特别的HMAC验证的实现。这个实现正好来自Keyczar库
of HMAC verification. This happens to be
an implementation from the Keyczar library,

5
00:00:15,941 --> 00:00:20,003
它是用Python写的。这是用于验证HMAC标签的代码
that happens to be written in Python. So
here's the code that's used to verify a

6
00:00:20,003 --> 00:00:23,709
这个代码实际上被简化了
tag generated by HMAC. This code is
actually simplified. I just wanted to

7
00:00:23,709 --> 00:00:27,822
我只想尽量简化它，以直击要点
kinda simplify it as much as I can to get
the point across. So basically, what the

8
00:00:27,822 --> 00:00:32,235
输入为密钥、信息和标签。我们验证的方法是
inputs are, the key, the message, and the
tag bytes. The way we verify it is, we

9
00:00:32,235 --> 00:00:38,082
重新计算信息的HMAC，然后比较得到的16字节
re-compute the HMAC on the message and
then we compare say the resulting sixteen

10
00:00:38,082 --> 00:00:43,271
与实际给的签名16字节。这看上去很好
bytes, to the actual given signature
bytes. So this looks perfectly fine.

11
00:00:43,271 --> 00:00:47,834
事实上，任何人可以想到这样实现它。
也已经有很多人像这样实现了
In fact, anyone might implement it like this.
And, in fact, many people have implemented

12
00:00:47,834 --> 00:00:52,231
问题是，如果你看这里的比较是如何实现的
it like this. The problem is, that if you
look at how the comparison is done, the

13
00:00:52,231 --> 00:00:56,740
你可能觉得，比较应该是逐字节地进行
comparison, as you might expect, is done
byte by byte. There's a loop inside of the

14
00:00:56,740 --> 00:01:01,373
Python翻译器里有一个循环遍历所有16个字节
Python interpreter that loops over all
sixteen bytes. And it so happens that the

15
00:01:01,373 --> 00:01:06,297
第一次它发现不相等的话，循环终止
first time it finds an inequality, the
loop terminates and says the strings are

16
00:01:06,297 --> 00:01:10,972
说两字符串不相等。当找到第一个不相等的字节
就退出比较的这一事实
not equal. And the fact that the
comparator exits when the first inequality

17
00:01:10,972 --> 00:01:16,146
造成了针对该密码库的一个严重的计时攻击
is found introduces a significant timing
attack on this library. So let me show you

18
00:01:16,146 --> 00:01:21,257
我来告诉大家如何攻击。设想你是攻击者，你有信息m
how one might attack it. So imagine you're
the attacker, and you have the message m,

19
00:01:21,257 --> 00:01:26,368
你想获得m的一个有效标签。现在，你的目标是攻击一个服务器
for which you want to obtain a valid tag.
Now, your goal is to attack a server that

20
00:01:26,368 --> 00:01:31,230
这个服务器存放着HMAC的密钥。这个服务器开放了一个接口
has an HMAC secret key stored in it. And
the server exposes an interface that

21
00:01:31,230 --> 00:01:36,089
这个接口接收信息与MAC，检查这个MAC是否有效
basically takes message MAC pairs. Checks
that the MAC is valid, if the MAC is valid

22
00:01:36,089 --> 00:01:40,450
如果MAC有效，服务器用这个信息进行操作；
如果MAC无效，服务器拒绝
it does something with the message. And if
the MAC is not valid, it says reject.

23
00:01:40,450 --> 00:01:45,039
退回到信息发送方，或拒绝这条信息
Okay, so it's back to the originator or
the message rejects. So now this attacker

24
00:01:45,039 --> 00:01:49,685
现在这个攻击者有机会提交大量信息
has an opportunity to basically submit
lots of message it appears and see if it

25
00:01:49,685 --> 00:01:54,274
看看能不能推出特定的攻击信息的标签
can deduce the tags of the particular
message for which it once attacked. Here's

26
00:01:54,274 --> 00:01:59,036
我们可以使用根据上一页的被破解的实现来做
how we might use the broken implementation
from the previous slide to do just that.

27
00:01:59,036 --> 00:02:03,661
攻击者提交许多信息，询问信息的标签
So what the attacker is gonna do is to
submit many message tag queries, where the

28
00:02:03,661 --> 00:02:08,044
而信息始终是一样的，但对于标签来说
message is always the same. But with a
tag, he's gonna experiment with lots and

29
00:02:08,044 --> 00:02:12,595
攻击者尝试很多不同的标签。在第一个询问里
lots and lots of different tags. So in the
first query, what he's gonna do is just

30
00:02:12,595 --> 00:02:17,202
攻击者提交目标信息和一个随机标签
submit a random tag along with the target
message. And he's gonna measure how long

31
00:02:17,202 --> 00:02:21,674
然后攻击者测量服务器的反应时间。他提交的下一个询问
the server took to respond. The next query
that he's gonna submit, is he's gonna try

32
00:02:21,674 --> 00:02:25,896
将尝试标签的第一字节的所有256种情况。
我来解释一下我的意思
all possible first bytes for the tags. Let
me explain what I mean by that. So the

33
00:02:25,896 --> 00:02:30,011
而标签中剩下的字节是任意选取的
remaining bytes of the tags that he
submits are just arbitrary, doesn't really

34
00:02:30,011 --> 00:02:34,557
它们是什么并不重要。但对于第一个字节
matter what they are. But for the first
byte, what he'll do is he'll submit a tag

35
00:02:34,557 --> 00:02:39,392
攻击者会提交一个以0字节开头的标签，
然后他观察服务器是否比之前
starting with a byte zero. And then he's
gonna see whether the server took a little

36
00:02:39,392 --> 00:02:44,285
花稍微长一点的时间来验证标签。
如果服务器花了与第一步严格相同的时间
bit longer to verify the tag than before.
If the server took exactly the same amount

37
00:02:44,285 --> 00:02:49,062
来验证这个标签，那么攻击者会再次尝试
of time to verify the tag as in step one,
then he's gonna try again, this time with

38
00:02:49,062 --> 00:02:52,976
这次以字节1开头。如果服务器依然反应迅速
bytes at one. If still the server
responded very quickly, he's going to try

39
00:02:52,976 --> 00:02:56,961
攻击者会尝试以字节2开头。如果服务器还是反应迅速
with byte sets of two. If the server
responded quickly then he's going to try

40
00:02:56,961 --> 00:03:01,101
攻击者会尝试以字节3开头，等等。。直到，比如说
with byte sets of three, and so on until
finally, let's say, when the byte sets of

41
00:03:01,101 --> 00:03:05,344
以3开头时，服务器花了稍微长一点的时间给出反应
three the server takes a little bit longer
to respond. What that means is actually

42
00:03:05,344 --> 00:03:09,484
就意味着当服务器比较正确的MAC和攻击者提交的MAC时
when it did the comparison between the
correct MAC and the MAC submitted by the

43
00:03:09,484 --> 00:03:14,334
在这个字节上，两个MAC是一样的，而不一样的是第二个字节
attacker. The two matched on this byte,
and the rejection happened on the second

44
00:03:14,334 --> 00:03:19,073
现在攻击者知道标签的第一个字节是3了
bytes. Aha. So now the attacker knows that
the first byte of the tag is set to three

45
00:03:19,073 --> 00:03:23,435
现在他可以对第二个字节实施一模一样的攻击
and now he can mount exactly the same
attack on the second byte. So here. It's

46
00:03:23,435 --> 00:03:28,519
提交这个标签。第二个字节，我用不同颜色
going to submit the tag. And the second,
back here, let me use a different color. So

47
00:03:28,519 --> 00:03:32,514
攻击者会提交一个标签，标签的第二个字节是0
it's gonna submit a tag when the second
byte is set to zero. And it's gonna

48
00:03:32,514 --> 00:03:36,516
攻击者将测量这是否会花比第二步更长的时间
measure whether this took a little bit
longer than in step two. If not, he's

49
00:03:36,516 --> 00:03:40,502
如果不是，他将把第二个字节换成1
gonna change this to be set to one, and
he's gonna measure if the server's

50
00:03:40,502 --> 00:03:44,758
攻击者将测量服务器的反应时间，是否比之前长
response time is a little longer than
before. Eventually, let's say when he sets

51
00:03:44,758 --> 00:03:48,960
最终，攻击者会把第二个字节设为，不太清楚，
比如说是53吧，突然间
this to, I don't know. When the byte is
set to, to 53, say, all of a sudden, the

52
00:03:48,960 --> 00:03:52,677
服务器反应的时间稍微长一点了
server takes a little bit longer to
respond. Which means that now, the

53
00:03:52,677 --> 00:03:56,943
这意味着比较器在前两个字节上是匹配的。
现在攻击者学习到了
comparator matched on the first two bytes.
And now the attacker learned that the

54
00:03:56,943 --> 00:04:01,056
MAC的前两个字节分别是3和53。现在攻击者可以继续
first two bytes of the MAC are three and
53. And now he can move on and do the

55
00:04:01,056 --> 00:04:05,274
对第三个字节进行同样的攻击，接着第4个字节，等等
exact same thing on the third byte and
then on the fourth byte and so on and so

56
00:04:05,274 --> 00:04:09,175
最终，服务器说，好，我接受
forth. Until finally, the server says,
yes, I accept. You actually gave me the

57
00:04:09,175 --> 00:04:13,858
你已经给我正确的MAC了。然后我们继续
在这个假信息上做手脚，攻击我们的服务器
right MAC. And then we'll go ahead and act
on this bogus message. That, attack our

58
00:04:13,858 --> 00:04:18,711
那么这是一个漂亮的攻击实例，如何使用计时攻击
supply. So this is a beautiful example of
how a timing attack can reveal the value

59
00:04:18,711 --> 00:04:23,140
来找到MAC值，正确的MAC。一字节、一字节地
of a MAC, the correct value of the MAC.
Kind of byte by byte, until eventually,

60
00:04:23,140 --> 00:04:28,094
知道攻击者获得标签中所有正确的字节
the attacker obtains all the correct bytes
of the tag, and then he's able to fool the

61
00:04:28,094 --> 00:04:32,640
然后他就可以欺骗服务器接收信息的标签。
我喜欢讲这个例子的原因是
server into accepting this message tag
pair. The reason I like this example is

62
00:04:32,640 --> 00:04:37,186
这是一个非常合理的实现MAC验证的程序
this is a perfectly reasonable way of
implementing a MAC verification routine.

63
00:04:37,186 --> 00:04:41,941
如果你这样实现，它会被完全破解的，那我们怎么办？
And yet, if you write it this way, it will
be completely broken. So what do we do? So

64
00:04:41,941 --> 00:04:46,509
让我们告诉大家两种防御方法，第一种是重新用Python写
let me show you two defenses, the first
defense, I'll write it in again in python

65
00:04:46,509 --> 00:04:51,020
事实上Keyczar严格地实现了这种防御
is, is as follows. In fact the Keyczar
library exactly implemented this defense.

66
00:04:51,020 --> 00:04:55,588
这份代码已经出现在更新版本的库中了
This code is actually taken out of the
updated version of the library. The first

67
00:04:55,588 --> 00:05:00,328
首先我们看攻击者提交的签名的字节数是否正确
thing we do is we test if the signature
bytes submitted by the attacker are of the

68
00:05:00,328 --> 00:05:04,896
对于HMAC来说是96位或128位
correct length, say for HMAC this would
be say, you know 96 bits or 128 bits, and

69
00:05:04,896 --> 00:05:09,421
如果不是，我们就不承认这是个有效的MAC。
现在，如果签名确实有正确的长度
if not we reject that as an invalid MAC.
But now, if the signature bytes really do

70
00:05:09,421 --> 00:05:13,466
我们实现这个比较器
have the correct length, what we do is
implement our own comparator. And it

71
00:05:13,466 --> 00:05:17,895
它总是花相同的时间比较两个字符串。特别地
always takes the same amount of time to
compare the two strings. So in particular,

72
00:05:17,895 --> 00:05:22,159
这里使用了Python里的zip函数
this uses the zip function in Python,
which will, essentially, if you are giving

73
00:05:22,159 --> 00:05:28,116
给了两个16字节的字符串，它会生成16对
it two sixteen byte strings. It will
create sixteen pairs. Of bytes. So it'll

74
00:05:28,116 --> 00:05:32,666
它会产生一个16个元素的列表，每个元素是一对字节
just create a, a list of sixteen elements,
where each element is a pair of bytes. One

75
00:05:32,666 --> 00:05:37,051
一个取自左边，另一个取自右边。当你循环时
taken from the left and one taken from the
right. And then you loop, you know, you

76
00:05:37,051 --> 00:05:41,326
循环这个列表时，计算第一对的异或
loop through this list of pairs. You
compute the XOR of the first pair, and the

77
00:05:41,326 --> 00:05:45,492
然后取或作为结果；再计算第二对的异或
OR into the result. Then you
compute the XOR of the second pair, and

78
00:05:45,492 --> 00:05:49,932
然后取或作为结果。大家注意到，如果这个循环里的任何一处
you OR that into the result. And
you note that, if at any point in this

79
00:05:49,932 --> 00:05:54,207
两个字节正好不一样，那么它们的异或不为0
loop, two bytes happen to be not equal,
then the XOR will evaluate to something

80
00:05:54,207 --> 00:05:58,577
所以当我们取异或结果的或时
that's non zero. And therefore, when we
OR'ed it into the result. The result

81
00:05:58,577 --> 00:06:02,632
结果也就是在计数0，在比较的最后我们会返回假值
will also be counting on zero, and then
we'll return false, at the end of the

82
00:06:02,632 --> 00:06:06,578
所以这里的比较器总是花同样长的时间
comparison. So the point here is that now
the comparator always takes the same

83
00:06:06,578 --> 00:06:10,720
即使它在第三个字节处找到了不同
amount of time. Even if it finds
difference in byte number three, it will

84
00:06:10,720 --> 00:06:15,479
它也会继续运行直到最后
continue running down the both strings
until the very end. And only then will it

85
00:06:15,479 --> 00:06:20,244
然后才返回结果。现在计时攻击被认为是不可能了
return the results. So now the timing
attack supposedly is impossible. However,

86
00:06:20,244 --> 00:06:25,256
但这样做也很有问题，因为编译器可能会帮倒忙
this can be quite problematic, because
compilers tried to be too helpful here. So

87
00:06:25,256 --> 00:06:30,143
一个优化的编译器可能看到这份代码后说
an optimized compiler might look at this
code and say, hey, wait a minute. I can

88
00:06:30,143 --> 00:06:35,107
等一下，我们可以优化这份代码，让这个愚蠢的循环
一旦发现不匹配的字节就结束
actually improve this code by making the
fool loop end as soon as an incompatible

89
00:06:35,107 --> 00:06:39,378
因此一个优化的编译器可能是你的
set of bytes is discovered. And so, an
optimizing compiler could be your, kind

90
00:06:39,378 --> 00:06:43,930
阿喀琉斯的脚后跟，当需要程序运行时间相同时。
of, Achilles heel when it comes to making
programs always take the same amount of
(阿喀琉斯的脚后跟：弱点的意思，见希腊神话)

91
00:06:43,930 --> 00:06:48,482
另一个不一样的防御并不是被广泛实现的
time. And so a different defense, which is
not as widely implemented, is to try and

92
00:06:48,482 --> 00:06:52,978
这种攻击试图把字符串的比较对攻击者隐藏起来
hide from the adversary, what strings are
actually being compared. So let me show

93
00:06:52,978 --> 00:06:57,417
我来告诉大家什么意思。这里有我们的验证算法
you what I mean by that. So again, here we
have our verification algorithm. So it

94
00:06:57,417 --> 00:07:01,740
它取密钥、信息和一个攻击者提供的候选MAC作为输入
takes as inputs, a key, a message, and a
candidate's MAC from the adversary. And

95
00:07:01,740 --> 00:07:06,156
然后，我们进行比较，首先计算信息的正确MAC
then, the way we do the comparison is we
first of all, compute the correct MAC on

96
00:07:06,156 --> 00:07:10,407
但然后不直接比较MAC和攻击者的签名
the message. But then instead of directly
comparing the MAC and the signature

97
00:07:10,407 --> 00:07:14,933
我们再取一次哈希值
bytes adversary, what we're gonna do
is we're gonna hash one more time. So we

98
00:07:14,933 --> 00:07:19,459
我们计算MAC的哈希值，我们计算签名的哈希值
compute a hash here of the MAC. We compute
a hash of the signature bytes. Of course,

99
00:07:19,459 --> 00:07:23,765
当然，如果这两个是一样的，那它们的哈希也是一样的
if these two happen to be the same, then
the resulting HMACs will also be the

100
00:07:23,765 --> 00:07:27,794
所以这个比较会成功
same, so the comparison will actually
succeed. But the point is now, if sig

101
00:07:27,794 --> 00:07:31,690
如果签名和MAC的第一个字节一样，
先不管其他字节的情况
bytes happen to equal MAC on the first
byte, but not on the remaining bytes.

102
00:07:31,690 --> 00:07:35,607
我们再算一次哈希，很有可能这两个
Then, when we do this additional hash
layer, it's likely that the two resulting

103
00:07:35,607 --> 00:07:39,675
得到的值是完全不一样的。因此，逐字节的比较器
values are completely different. And as a
result, the byte by byte comparator will

104
00:07:39,675 --> 00:07:43,693
会在第一轮就完成输出。这里攻击者将无法知道
just output on the first iteration. The
point here is that the adversary doesn't

105
00:07:43,693 --> 00:07:47,258
到底在比较什么字符串。因此
actually know what strings are being
compared. And as a result, he can't

106
00:07:47,258 --> 00:07:50,809
他不能像我们之前讨论的那样实施计时攻击
mount a timing attack that we
discussed earlier. Okay, so this is

107
00:07:50,809 --> 00:07:55,447
这就是另一种防御。至少现在，你不用听优化的编译器的摆布了
another defense. At least now, you're not
at the mercy of an optimizing compiler.

108
00:07:55,447 --> 00:08:00,027
这里主要的教训是，即使是专家
The main lesson from all of this is that
you realize that people who even are

109
00:08:00,027 --> 00:08:04,490
在实现密码库时，也会犯这种错误
experts at implementing cryptolibraries,
get this stuff wrong. And the right code

110
00:08:04,490 --> 00:08:08,351
能很好工作的代码，对计时攻击来说也是脆弱的
that works perfectly fine and yet is
completely vulnerable to a timing attack

111
00:08:08,351 --> 00:08:12,310
这就让整个系统的安全性功亏一篑。
然后，这里的教训是
that completely undo all security of the
system. So the lesson here is of course

112
00:08:12,310 --> 00:08:15,775
大家不应该自己发明密码
you should not be inventing your own
crypto but you shouldn't even be

113
00:08:15,775 --> 00:08:19,785
甚至不应该自己实现密码，因为极有可能
你的实现对旁道攻击是脆弱的
implementing your own crypto because most
likely it'll be vulnerable to the side

114
00:08:19,785 --> 00:08:23,546
请使用标准库，比如OpenSSL
channel attacks. Just use a standard
library like OpenSSL. Keyczar is actually a

115
00:08:23,546 --> 00:08:27,605
Keyczar也是很好的密码库，可以降低对这些攻击
fine library to use that would reduce the
chances that you're vulnerable to these

116
00:08:27,605 --> 00:08:28,447
脆弱的可能性
types of attacks.

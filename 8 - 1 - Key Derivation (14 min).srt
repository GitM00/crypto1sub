1
00:00:00,000 --> 00:00:03,515
对称密码学我们快讨论完了
Well, we're almost done with our
discussion of symmetric encryption. There

2
00:00:03,515 --> 00:00:06,471
还有些零零碎碎的东西我这里想讨论一下
are just a couple of odds and ends that
I'd like to discuss before we move on to

3
00:00:06,471 --> 00:00:10,431
然后我们再谈下一话题。首先我想提一下，
如何从一个密钥推出多个密钥
the next topic. So the first thing I'd
like to mention is how we derive many keys

4
00:00:10,431 --> 00:00:14,497
实际上，这点全部来自于实践
from one key. And it, actually, this comes
up all the time in practice, so I'd like

5
00:00:14,497 --> 00:00:18,287
我想确保大家知道，如何正确地操作
to make sure you know how to do this
correctly. So what's the setting that

6
00:00:18,287 --> 00:00:22,775
我们在看什么样的设定？设想我们有一个特定的源密钥
we're looking at? Well, imagine we have a
certain source key that's generated by one

7
00:00:22,775 --> 00:00:26,435
源密钥有很多种方法生成。设想源密钥是由
of a number of methods. Imagine the
source key is generated by a hardware

8
00:00:26,435 --> 00:00:30,094
一个硬件随机数发生器生成的，或者
可能是由密钥交换协议生成的
random number generator or perhaps is
generated by a key exchange protocol

9
00:00:30,094 --> 00:00:34,036
我们稍后讨论密钥交换协议。有很多方法
which we're going to discuss later. But
anyhow, there are a number of ways in

10
00:00:34,036 --> 00:00:38,110
可以生成Alice和Bob之间的源密钥
which a source key might be generated
between Alice and Bob, such that the

11
00:00:38,110 --> 00:00:42,569
这样攻击者不知道源密钥是什么。现在，如我们所说
attacker doesn't know what the source key
is. But now, as we said, in many cases, we

12
00:00:42,569 --> 00:00:46,863
在很多情况下，我们需要很多密钥来保证会话的安全，
不仅仅是单个源密钥
actually need many keys to secure a
session, not just one single source key.

13
00:00:46,863 --> 00:00:51,267
例如，如果大家记得，在TLS里，有一些单向密钥
For example, if you remember, in TLS there
were unidirectional keys and we

14
00:00:51,267 --> 00:00:55,285
我们每个方向都需要不同密钥。事实上在每个方向
needed keys in each direction. And in
fact, in each direction, we needed

15
00:00:55,285 --> 00:00:59,469
我们需要多个密钥。我们需要一个MAC密钥，
我们需要一个加密密钥。我们需要一个IV
multiple keys. We needed a MAC key, we
needed an encryption key. We need an IV,

16
00:00:59,469 --> 00:01:03,093
等等。。类似地还有基于新鲜值的加密，大家记得
and so on. Similarly nonce based
encryption, you remember, there were

17
00:01:03,093 --> 00:01:07,594
使用了多个密钥，等等。那么问题是
multiple keys that were being used, and so
on. And so, the question is, how do we use

18
00:01:07,594 --> 00:01:12,031
我们如何使用一个源密钥，从一个硬件过程
the one source key that we just derived,
either from a hardware process or

19
00:01:12,031 --> 00:01:16,351
或密钥交换，来生成一堆密钥，可以用这些密钥
by key exchange, and generate a bunch of
keys from it that we could then use to

20
00:01:16,351 --> 00:01:20,531
来保证我们的会话安全。这个使用所谓的
secure our session. The way that's done,
is using a mechanism called a key

21
00:01:20,531 --> 00:01:24,951
密钥推导函数(KDF)来实现。我想多讨论一点
derivation function, KDF. And I want to
talk a little bit about how KDF's are

22
00:01:24,951 --> 00:01:29,846
KDF是如何组建的。首先，假设我们有一个安全的PRF
constructed. So first of all, suppose we
have a secure PRF, that happens to have

23
00:01:29,846 --> 00:01:34,993
正好有密钥空间K。现在，假设我们的源密钥SK
key space K. And now, suppose that it so
happens that our source key SK is uniform

24
00:01:34,993 --> 00:01:41,207
在密钥空间K中均匀分布。这时，源密钥实际上是
安全PRF F的一个均匀随机密钥
in the key K. In this case, the source key
is, in fact, a uniform random key for the

25
00:01:41,207 --> 00:01:46,453
我们可以直接使用它来生成多个密钥
secure PRF F. And we can use it directly to
generate keys, all the keys that we need

26
00:01:46,453 --> 00:01:50,444
我们需要这些密钥来保证会话的安全。这种情况下，KDF很简单
to secure the session. So in this case,
the KDF is really simple. The key

27
00:01:50,444 --> 00:01:53,771
这个密钥推导函数如下工作。它取源密钥为输入
derivation function would just work as
follows. It would take as input the

28
00:01:53,771 --> 00:01:58,025
它还取一个参数上下文作为输入
source key. It would take an input, a
parameter context, which I'm gonna

29
00:01:58,025 --> 00:02:02,766
我待会来描述这个参数。取输入的长度作为输入
describe in just a minute. And then it's
gonna take a length input as input as

30
00:02:02,766 --> 00:02:07,615
然后计算PRF在0处的值
well. And then what it will do is it will
basically evaluate the PRF on zero. Then

31
00:02:07,615 --> 00:02:12,400
然后计算PRF在1处的值，然后计算PRF在2处的值，直到L
it will evaluate the PRF on one. Then it
will evaluate the PRF on two, up until L.

32
00:02:12,400 --> 00:02:16,449
我待会讨论这里的上下文
And I will talk about what this context is
in just a second. And then, basically, you

33
00:02:16,449 --> 00:02:20,353
使用输出中你需要的那么多位，来生成
would use as many bits of the output as
you would need to generate all the keys

34
00:02:20,353 --> 00:02:24,256
会话的全部密钥。如果需要生成单向密钥
for the session. So, if you need unidirectional keys you would generate, you

35
00:02:24,256 --> 00:02:28,355
每个方向都有一个密钥，包括加密密钥和一个MAC密钥
know, one key in each direction where each key
might include an encryption key and a MAC

36
00:02:28,355 --> 00:02:32,356
这样，你会生成你需要的那么多位
key. And so, you would basically generate
as many bits as you need and then finally

37
00:02:32,356 --> 00:02:36,259
最后截断输出，当你生成了足够多的密钥来保护会话
cut off the output at the time when you've
generated enough keys to secure your

38
00:02:36,259 --> 00:02:41,177
这是一个很直白的机制
session. Okay so this is a fairly straight
forward mechanism it's basically using the

39
00:02:41,177 --> 00:02:45,656
它使用了安全的PRF作为一个伪随机数发生器。唯一的问题是
secure PRF as a pseudo random generator.
And the only question is what is its

40
00:02:45,656 --> 00:02:49,451
它的上下文字符串。我告诉大家，这个上下文字符串
context string. Well, I'll tell you that
the context string is basically a unique

41
00:02:49,451 --> 00:02:53,545
是一个唯一的字符串，作为应用的身份。所以
实际上你可以在一个系统上有多个应用
string that identifies the application. So
in fact you might have multiple

42
00:02:53,545 --> 00:02:58,304
多个应用试着建立多种安全密钥
applications on the same system that's
trying to establish multiple secure keys.

43
00:02:58,304 --> 00:03:03,169
也许你有一个进程运行SSH，还有另一个进程
运行着网页服务器
Maybe you have SSH running as one process,
you have a web server running as another process,

44
00:03:03,169 --> 00:03:09,145
第三个进程是IPsec，所有这三个进程都有密钥生成
IPsec as a third process and all three need 
to have secret keys generated. And this

45
00:03:09,145 --> 00:03:13,533
这个上下文变量试图把他们三个分开。我问大家
context variable basically tries to separate 
the three of them. So, let me ask you,

46
00:03:13,533 --> 00:03:16,589
更精确地说，你认为上下文变量的目的是什么？
more precisely, what do you think 
the purpose of this context variable is?

47
00:03:19,204 --> 00:03:22,312
我想我已经给出了答案
So I guess I've given
it away and this context variable is

48
00:03:22,312 --> 00:03:26,166
上下文变量用来分离各个进程，比如说
supposed to basically separate
applications, so that even if, for

49
00:03:26,166 --> 00:03:30,863
即使我们刚刚说的这三个服务：SSH，网页服务器和IPsec
example, the three services that we just
talked about, SSH, web server, and IPsec,

50
00:03:30,863 --> 00:03:35,741
如果它们都从硬件的随机数发生器获得了同样的源密钥
if they all happen to obtain the same
source key from the hardware random number

51
00:03:35,741 --> 00:03:40,378
那么由于三个应用的上下文不同
generator then the context since it's
different for the three apps will make

52
00:03:40,378 --> 00:03:45,617
可以确保它们依然获得独立的字符串，可以用来保护会话安全
sure that they still get three independent
strings that they can then use to secure

53
00:03:45,617 --> 00:03:49,873
我就想让大家记住，尽管这个方法很直接
the sessions. I just want you to remember
that, even though this is actually fairly

54
00:03:49,873 --> 00:03:53,648
我们之前也讨论过，上下文字符串是重要的
straightforward, and we discussed this
before, the context string is actually

55
00:03:53,648 --> 00:03:57,374
对应用而言必须是特有的
important, and it does need to be specific
to the application, so that each

56
00:03:57,374 --> 00:04:01,300
使得每个进程有属于自己的会话密钥，
即使多个进程正好有同样的源密钥SK
application gets its own session keys,
even if multiple applications happen to

57
00:04:01,300 --> 00:04:05,139
下个问题是，如果源密钥不是均匀分布的
sample the same SK. The next
question is, what do we do if the source

58
00:04:05,139 --> 00:04:09,714
我们该怎么办？现在我们就有问题了。如果源密钥
key actually isn't uniform? Well, now we
got a problem. If the source key is not a

59
00:04:09,714 --> 00:04:14,113
不是均匀分布的密钥，对于伪随机函数来说，我们不能继续假设
uniform key for the pseudo random function
then we can no longer assume that the

60
00:04:14,113 --> 00:04:18,511
伪随机函数的输出是与随机函数的输出不可区分的了
output of the pseudo random function is
indistinguishable from random. In fact, if

61
00:04:18,511 --> 00:04:23,841
事实上，如果我们只使用我们刚刚描述的KDF，
其输出看起来可能并不随机
we just use the KDF that we just described
then the output might not look random to

62
00:04:23,841 --> 00:04:27,416
这样攻击者可能可以预期某些我们使用的会话密钥
the adversary and then he might be able to
anticipate some of the session keys that

63
00:04:27,416 --> 00:04:31,562
进而破解会话。所以我们有问题了
we'll be using and thereby break the
session. So then we have a problem. Now

64
00:04:31,562 --> 00:04:35,510
为什么这个源密钥会不是随机分布的呢？这有很多原因的
why would this source key not be uniform?
Well there are many reasons why this

65
00:04:35,510 --> 00:04:39,560
比如说，如果你使用一个密钥交换协议
happened. For example if you use a key
exchange protocol, it so happens typically

66
00:04:39,560 --> 00:04:42,826
很可能这个密钥交换协议会生成一个高熵的密钥
that key exchange protocols will generate a
high entropy key. But the
(高熵意味着字符串的分布接近均匀，但不是均匀分布)

67
00:04:42,826 --> 00:04:46,774
高熵的密钥分布于密钥空间的一个子空间
high entropy key is gonna be
distributed in some subspace of the key

68
00:04:46,774 --> 00:04:51,455
那么这个密钥不是均匀分布的字符串
space. So it's not going to be a uniform
string. It will be uniform in some

69
00:04:51,455 --> 00:04:55,763
它会是某个更大集合的子集上的均匀分布。
我们会看些例子，等我们讨论密钥交换协议
subset of a larger set. And we'll see
examples of that as soon as we talk about

70
00:04:55,926 --> 00:05:00,317
所以KDF必须适应密钥交换协议
key exchange protocols. And so KDFs have
to kind of accommodate for the fact that

71
00:05:00,317 --> 00:05:04,492
不能生成均匀分布的字符串这一事实
key exchange protocols actually don't
generate uniform bit strings. The other

72
00:05:04,492 --> 00:05:08,830
另一问题是，事实上，大家使用的硬件随机数发生器
problem is, that, in fact, the hardware
random number generator you're using might

73
00:05:08,830 --> 00:05:13,384
可能也会生成不均匀的输出。我们不想依赖
actually produce biased outputs. We don't
wanna rely on the non bias of the hardware

74
00:05:13,384 --> 00:05:17,252
输出不均匀的硬件随机数发生器。所以我们
只能假设输出结果含有高熵
random number generator. And so all we
want to assume is that it generates a high

75
00:05:17,252 --> 00:05:21,842
但可能是不均匀的。这种情况下
entropy string, but one that might be
biased. In which case, we have to somehow

76
00:05:21,842 --> 00:05:26,735
我们必须从某种意义上清楚这种不均匀。所以
这就引入了这种构建KDF的机制
clean this bias. And so this introduces 
this, this paradigm for building KDFs.

77
00:05:26,735 --> 00:05:31,962
叫做先提取再扩展的机制
This is called the extract-then-expand 
paradigm, where the first step

78
00:05:31,962 --> 00:05:37,247
KDF的第一步是从实际源密钥中提取一个伪随机密钥
of the KDF is to extract a pseudo random
key from the actual source key. So in a

79
00:05:37,247 --> 00:05:40,829
在这张图里，大家可以想到这点。
某种意义上，源密钥有多种可能的值
picture you can think about it like this.
In some sense these are the different

80
00:05:40,829 --> 00:05:45,343
这条水平线和这条垂直轴
possible values of the source key. This is
the horizontal line and the vertical axis

81
00:05:45,343 --> 00:05:49,541
表示这些值的概率分布，大家可以看到
is basically the probability of each one
of these values, and you can see that this

82
00:05:49,541 --> 00:05:53,464
这是一个分布崎岖的函数，说明源密钥
is a kind of a bumpy function which would
say that the source key is not uniformly

83
00:05:53,464 --> 00:05:58,561
并不是在密钥空间上均匀分布的。这里我们使用
distributed in the key space. What we do
in this case is we use what's called an

84
00:05:58,561 --> 00:06:02,913
所谓的提取器，提取器取这个不均匀的函数为输入
extractor. So an extractor is something
that takes a bumpy distribution and makes

85
00:06:02,913 --> 00:06:07,462
把它变成一个密钥空间上的均匀分布
it into a uniform distribution over the
key space. In our case we're actually just

86
00:06:07,462 --> 00:06:10,027
这里我们使用所谓的计算提取器
gonna be using what are called
computational extractors, namely

87
00:06:10,027 --> 00:06:14,894
这种提取器最后不一定产生均匀分布的输出
extractors that don't necessarily produce
uniform distribution at the end but

88
00:06:14,894 --> 00:06:20,257
但生成的分布与真的均匀分布不可区分
they generated distribution that's
indistinguishable from uniform.

89
00:06:22,910 --> 00:06:27,323
现在提取器取一个盐作为输入
Now extractors typically take as input
something called a salt, and a salt just

90
00:06:27,323 --> 00:06:31,318
就像撒拉里的盐，增加口感
like in a salad, it kind of adds flavor to
things, what it does is basically kind of

91
00:06:31,318 --> 00:06:36,022
这个盐的作用就是捣乱，不管输入分布如何
jumbles things around, so that no matter
what the input distribution is, the output

92
00:06:36,022 --> 00:06:39,738
输出分布依然与随机分布不可区分
distribution is still going to be
indistinguishable from random. So a salt

93
00:06:39,738 --> 00:06:43,973
什么是盐？盐不是秘密的字符串，是公开知道的
basically, what is it? It's a non-secret
string, so it's publicly known. It doesn't

94
00:06:43,973 --> 00:06:48,565
如果攻击者知道盐也无所谓，而且盐是固定的值
matter if the adversary knows what the
salt is, and it's fixed forever. The only

95
00:06:48,565 --> 00:06:53,096
唯一一点是让你选择盐时，你是随机选择的
point is that when you chose it, you chose
one at random. And then the hope is that

96
00:06:53,096 --> 00:06:57,173
试图提取的有趣的分布本质上
the funny distribution that you're trying
to extract from kinda doesn't inherently

97
00:06:57,173 --> 00:07:00,274
并不依赖于你选择的盐，因此使用盐的结果
depends on the salt that you chose and
hence as a result using your salt, you

98
00:07:00,274 --> 00:07:03,729
是得到一个看起来与随机分布不可区分的分布
will actually get a distribution that
looks indistinguishable from random. So

99
00:07:03,729 --> 00:07:07,020
本质上要想获得盐，你可以脸滚键盘几次
essentially the salt, you know, you can
just bang it the keyboard a couple of

100
00:07:07,020 --> 00:07:10,220
只要保证是随机产生的即可
times when you generate it but it just
needs to be something that's random

101
00:07:10,220 --> 00:07:14,249
但是盐永远是固定的。如果攻击者知道盐也无所谓
initially but then it's fixed forever, and
it's fine if the adversary knows what

102
00:07:14,249 --> 00:07:20,304
不过提取器可以提取熵，并输出
it is and nevertheless the extractor is
able to extract the entropy and output a

103
00:07:20,304 --> 00:07:24,713
一个均匀分布的随机字符串K。某种意义上，
盐是用来防御
uniformly random string K. In some sense the
salt is only there to defend against

104
00:07:24,713 --> 00:07:29,667
可能会干扰提取器的恶意的坏分布
adversarially bad distributions that might
mess up our extractor. Okay, so now that

105
00:07:29,667 --> 00:07:34,581
现在我们提取了一个伪随机密钥。我们
可能也会在KDF中使用它
we have extracted a pseudo random key.
Now, we might as well just use it in a KDF

106
00:07:34,581 --> 00:07:38,911
我们刚刚看了使用安全的伪随机函数
that we just saw using a secure
pseudo random function to expand the key

107
00:07:38,911 --> 00:07:43,481
把密钥扩展成我们需要的那么多位，来保证会话安全
into as many bits as we need to actually
secure the session. Okay, so there are

108
00:07:43,481 --> 00:07:47,431
有这两步：首先我们提取一个伪随机密钥
these two steps. The first one is we
extract a pseudo-random key, and then once

109
00:07:47,431 --> 00:07:51,584
然后我们有了一个伪随机密钥，我们已经知道了
然后把它扩展成我们需要的那么多密钥
we have a pseudo-random key we already
know how to extend it into as many keys as

110
00:07:51,584 --> 00:07:56,033
用于伪随机函数。所以标准方法是
we need using a pseudo-random function. So
the standardized way of doing this is

111
00:07:56,033 --> 00:08:01,170
所谓的HKDF，它是一个KDF，是使用HMAC构建的密钥推导函数
called HKDF. This is a KDF, a key derivation function that's built from HMAC.

112
00:08:01,170 --> 00:08:06,561
这里HMAC既用于PRF进行扩展，又用于提取器
And here HMAC is used both as the PRF for
expanding and an extractor for extracting

113
00:08:06,561 --> 00:08:11,699
来提取最初的伪随机密钥。我来解释这是怎么工作的
the initial pseudo-random key. So let me
explain how this works. So in the extract

114
00:08:11,699 --> 00:08:16,900
在提取一步中，我们使用盐，一个公开值
step, we're gonna use our salt which you
remember is a public value just happened to

115
00:08:16,900 --> 00:08:21,101
这个盐是在开始时随机选取的。我们使用这个盐
be generated at random at the beginning of
time. And we use this salt as the HMAC

116
00:08:21,101 --> 00:08:27,526
作为HMAC的密钥。然后我们把源密钥作为HMAC的数据
key. And then the source key we're gonna
use as the HMAC data. So we're kind of

117
00:08:27,526 --> 00:08:32,292
我们使用一个公开值作为一个密钥。不过
using a public value as a key. And
nevertheless, one can argue that HMAC has

118
00:08:32,292 --> 00:08:37,623
可以证实HMAC有提取的性质，使得当我们应用HMAC时
extraction properties, such that, when we
apply HMAC, the resulting key is going to

119
00:08:37,623 --> 00:08:42,452
获得的密钥看起来与随机的不可区分，
假设源密钥有足够的熵
look indistinguishable from random,
assuming that the source key actually has

120
00:08:42,452 --> 00:08:47,329
现在我们有了这个伪随机密码
enough entropy to it. And now that we have
the pseudo random key we're simply going

121
00:08:47,329 --> 00:08:52,037
我们将要使用HMAC作为一个PRF来生成一个会话密钥
to use HMAC as a PRF to generate a
session key of you know as many bits as we

122
00:08:52,037 --> 00:08:56,389
生成我们需要的、用于会话密钥的那么多位。
我们对HKDF的讨论差不多就这些
need for the session keys. Okay. So that
basically concludes our discussion of

123
00:08:56,389 --> 00:09:00,763
我只想让大家记住，一旦有了源密钥
HKDF. And I just want you to remember
that, once you obtain a source key, either

124
00:09:00,763 --> 00:09:04,912
从硬件或密钥交换协议得来的，你把它转换成会话密钥
from hardware or from a key exchange
protocol, the way you convert it into

125
00:09:04,912 --> 00:09:09,566
不是通过使用直接的取样。永远不要直接使用源密钥
session keys is not by using that sample
directly. You would never use a source key

126
00:09:09,566 --> 00:09:14,108
作为协议里的会话密钥
directly as a session key in a protocol.
What you would do is you will run the

127
00:09:14,108 --> 00:09:18,369
将源密钥交给一个KDF，KDF会给你所有的密钥
source key through a KDF. And the KDF
would give you all the keys and output

128
00:09:18,369 --> 00:09:22,575
和你需要的输出，比如随机性、协议要用到的随机密钥
that you need, for, the randomness, for
the random keys to be used in your

129
00:09:22,575 --> 00:09:27,042
一个典型的KDF是HKDF，这里讨论了很多
protocol. And a typical KDF to use is
HKDF, which is actually getting quite a

130
00:09:27,042 --> 00:09:31,952
本节我想讨论的最后一个话题是
bit of traction out there. Okay. The last
topic I wanna talk about in this segment

131
00:09:31,952 --> 00:09:36,430
如何从密码中提取密钥。这些通常叫做
is, how do you extract keys from
passwords. These are called password based

132
00:09:36,430 --> 00:09:41,921
基于密码的KDF，或PBKDF。这里的问题是
密码通常含有较低的熵
KDFs or PBKDFs. The problem here is
that passwords have relatively low

133
00:09:41,921 --> 00:09:45,764
事实上，我们将在本课程稍后讨论密码
entropy. In fact, we're gonna talk about
passwords later on in the course when we

134
00:09:45,764 --> 00:09:50,154
等我们讨论用户认证时。所以我这里不打算讲太多
talk about user authentication. And so,
I'm not gonna say too much here. I'll just

135
00:09:50,154 --> 00:09:54,291
我只说密码通常含有很小的熵，约为20位左右的熵
say passwords generally have very little
entropy estimated on the order of twenty

136
00:09:54,291 --> 00:09:59,010
因此，这点熵对于根据密码生成会话密钥来说是不够的
bits of entropy, say. And as a result,
there is simply not enough entropy to

137
00:09:59,010 --> 00:10:02,882
我们还经常需要做这件事
generate session keys out of a password.
And yet we still need to do it very

138
00:10:02,882 --> 00:10:06,804
我们需要根据密码推导加密密钥和MAC密钥
frequently. We still need to derive
encryption keys and MACs and so on out of

139
00:10:06,804 --> 00:10:10,828
那么问题是怎么做？首先
passwords, so the question is how to do
it. The first thing is, you know, for this

140
00:10:10,828 --> 00:10:14,744
出于这种目的的话，不要使用HKDF，其设计与我们的目标不符
kind of purpose, don't use HKDF. That's
not what it's designed for. What will

141
00:10:14,744 --> 00:10:18,657
若使用HKDF，推导出的密钥对所谓的字典攻击是脆弱的
happen is that the derived keys will
actually be vulnerable to something called

142
00:10:18,657 --> 00:10:22,105
我们将在本课程稍后讨论字典攻击
a dictionary attack, which we're gonna
talk about much later in the course when

143
00:10:22,105 --> 00:10:27,787
等我们讨论用户认证时。那么PBKDF防御
we talk about user authentication. So, the
way PBKDFs defend against this low entropy

144
00:10:27,787 --> 00:10:33,002
造成字典攻击的低熵问题，通过两种手段
problem that results in a dictionary
attack is by two means. First of all, as

145
00:10:33,002 --> 00:10:38,878
首先，在使用盐前，盐是一个公开的固定值
before they use a salt, a public,
random value that's fixed forever. But in

146
00:10:38,878 --> 00:10:43,097
PBKDF还使用一个所谓的慢哈希函数
addition, they also use what's called a
slow hash function. And let me describe

147
00:10:43,097 --> 00:10:49,355
我来描述一种从密码推导密钥的标准方法，叫做PKCS #5
kind of the standard approach to deriving
keys from passwords. This is called PKCS #5,

148
00:10:49,355 --> 00:10:53,911
特别地，我要讨论的版本是PBKDF1
and in particular, the version I'll describe 
is what's called PBKDF1. And I
(现已有更新的版本PBKDF2)

149
00:10:53,911 --> 00:10:57,398
我应该说下，这个机制在大多数密码学库中都已实现
should say that this mechanism is
implemented in most crypto libraries so

150
00:10:57,398 --> 00:11:00,663
你不应该自己去实现
you shouldn't have to implement this
yourself. All you would do, you know, you

151
00:11:00,663 --> 00:11:03,788
你只要调用一个函数，由密码推导密钥
would call a function, you know, derived
key from password. You would give the

152
00:11:03,788 --> 00:11:08,353
给密码作为输入，你会得到一个密钥作为输出
password in as input, and you would get a
key as output. But you should be aware of

153
00:11:08,353 --> 00:11:11,741
不过大家应该意识到，这个密钥当然没有高熵
course that this key is not going to have
high entropy so in fact it will be

154
00:11:11,741 --> 00:11:17,155
所以事实上是可以猜出的。这些PBKDF试图让这个猜测问题
guessable. What these PBKDFs try to do is
make the guessing problem as hard as

155
00:11:17,155 --> 00:11:20,964
尽可能的困难。它们是这样工作的，首先，如我们所说
possible. Okay. So the way they work,
first of all, is, as we said, they

156
00:11:20,964 --> 00:11:25,693
它们计算密码联结上盐后，所得字符串的哈希值
basically hash, the concatenation of the
password and the salt. And then the hash

157
00:11:25,693 --> 00:11:29,170
然后这个哈希函数被设计成一个非常慢的哈希函数
itself is designed to be a very slow hash
function. And the way we build a slow hash

158
00:11:29,170 --> 00:11:34,063
构造一个慢哈希函数的方法是取一个特定的哈希函数
比如说，SHA-256
function is by taking one particular hash
function, say, SHA-256, and we

159
00:11:34,063 --> 00:11:39,425
我们迭代它很多次，记为C次。那么你可以想象有1000次
iterate it many, many times, C times. So
you can imagine 1000 times, perhaps even a

160
00:11:39,425 --> 00:11:43,356
也可能有一百万次。我说的迭代是什么意思？
million times. And what do I mean by
iterating it? So, well, we take the

161
00:11:43,356 --> 00:11:48,494
我们取密码和盐。我们把它们放在这个哈希函数的输入里
password and the salt. And we put them
inside of one input to the hash function.

162
00:11:48,494 --> 00:11:54,025
然后我们应用哈希函数，我像这样写
And then we apply the hash function, oops,
let me write it like this. And then we

163
00:11:54,025 --> 00:11:57,779
然后我们应用哈希函数，获得一个输出，
然后我们再应用哈希函数
apply the hash function and we get an
output, and then we apply the hash

164
00:11:57,779 --> 00:12:00,779
获得另一个输出。我们一次又一次地这样做
function again and we get another output.
And we do this again and again and again

165
00:12:00,779 --> 00:12:05,830
也许一千次或一百万次，取决于你的处理器有多快
maybe a thousand times or a million times
depending on how fast your processors are

166
00:12:05,830 --> 00:12:10,710
最终我们获得了最后的输出
and then finally we get the final output
that we actually output as, as the key

167
00:12:10,710 --> 00:12:15,057
作为这个密钥推导函数的密钥输出。要点是什么？
output of this key derivation function.
Now what is the point here? Iterating a

168
00:12:15,057 --> 00:12:19,371
迭代函数一万次或甚至一百万次，在现代处理器上
function 10,000 times or even a million
times is going to take very little time on

169
00:12:19,371 --> 00:12:22,922
只需要很短的时间，因此它不怎么影响用户体验
a modern CPU, and as a result, it doesn't
really affect the user's experience. The

170
00:12:22,922 --> 00:12:27,792
用户输入他的密码，它会哈希一百万次，获得输出
user types in his password, it gets hashed
a million times and then it gets output.

171
00:12:27,792 --> 00:12:31,654
也许那需要十分之一秒，用户不会注意到
And maybe that could even take, you know a
tenth of a second and the user wouldn't

172
00:12:31,654 --> 00:12:35,489
但攻击者可以尝试字典里的所有密码
even notice it. However the attacker, all
he can do is he can try all the passwords

173
00:12:35,489 --> 00:12:39,689
因为我们知道人们更愿意选择字典里的密码
in the dictionary, because we know people
tend to pick passwords in dictionaries,

174
00:12:39,689 --> 00:12:43,780
所以攻击者可以一个一个地尝试，记得盐是公开的
and so he could just try them one by one,
remember the SALT is public, so he knows

175
00:12:43,780 --> 00:12:49,232
所以攻击者知道盐，那么他可以一个一个地尝试这个哈希
what the SALT is. And so he can just try this
hash one by one. However because the hash

176
00:12:49,232 --> 00:12:53,796
但是因为这个哈希函数很慢，每一次尝试都要
花掉他十分之一秒的时间
function is slow, each attempt is gonna
take him a tenth of second. So if he needs

177
00:12:53,796 --> 00:12:57,965
所以如果他需要跑完一个字典，字典里有2千亿个密码
to run through a dictionary, you know, with,
with a 200 billion passwords in it,

178
00:12:57,965 --> 00:13:02,416
因为哈希函数速度慢，这要花掉攻击者很长的时间
because the hash function is slow, this is
gonna take quite awhile. And by doing

179
00:13:02,416 --> 00:13:06,584
通过这样做，我们减缓了字典攻击，使得攻击者
that, we slow down the dictionary attack,
and we make it harder for the attacker to

180
00:13:06,584 --> 00:13:11,608
更难猜中我们的会话密钥。虽不是不可能，但更困难
这就是PBKDF1所做的一切
get our session keys. Not impossible, just
harder. That's all this is trying to do.

181
00:13:11,608 --> 00:13:15,748
这就是关于基于密码的KDF我想说的
Okay, so this is basically what I wanted
to say about password based KDFs. As I

182
00:13:15,748 --> 00:13:19,835
如我所说，这不是大家自己去构建的
said, this is not something you would
build yourself. All crypto libraries have

183
00:13:19,835 --> 00:13:23,976
所有的密码学库都有PKCS #5机制的实现
an implementation of a PKCS #5
mechanism. And you would just call the

184
00:13:23,976 --> 00:13:28,275
你只需要合理地调用函数，就能把一个密码
转换成一个密钥，然后就能使用获得的密钥了
appropriate function to convert a password
into a key, and then use the resulting

185
00:13:28,275 --> 00:13:32,362
下节我们将看如何使用对称加密
key. Okay, in the next segment, we're
gonna see how to use symmetric encryption

186
00:13:32,362 --> 00:13:35,229
来在密文上进行搜索
in a way that allows us to search on the
cipher texts.

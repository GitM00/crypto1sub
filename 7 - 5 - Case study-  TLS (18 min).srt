1
00:00:00,000 --> 00:00:04,450
我想为大家展示一下，认证加密在现实中的应用
So I want to show you how authenticated
encryption is used in the real world, so

2
00:00:04,450 --> 00:00:08,844
我们用TLS作为一个例子，来看看TLS是如何工作的
let's use TLS as an example and see how
TLS works. So data encryption in TLS is

3
00:00:08,844 --> 00:00:13,183
在TLS中，数据加密使用的协议叫做TLS记录协议
done using a protocol called a TLS record
protocol. In this protocol, every TLS

4
00:00:13,183 --> 00:00:17,800
在这个协议栈，每个TLS记录都以一个报文头开始，
我们待会将看到报文头的格式
record starts with a header, we'll see the
structure of the header in just a minute,

5
00:00:17,800 --> 00:00:22,250
报文头后面接加密的数据，由一方发送到另一方的
followed by encrypted data that is sent
from one side to the other. In TLS, it so

6
00:00:22,250 --> 00:00:26,534
在TLS中，记录的长度最多为16KB
happens that the records are at most
sixteen kilobytes and if more data than

7
00:00:26,534 --> 00:00:30,984
如果需要发送多于16KB的数据，那么
sixteen kilobytes needs to be sent, then
basically the record is fragmented into

8
00:00:30,984 --> 00:00:35,401
一个记录需要被拆分成多个记录。现在，TLS
使用了单向密钥
multiple records. Now TLS uses what's
called unidirectional keys, meaning that

9
00:00:35,401 --> 00:00:40,087
意思是从浏览器到服务器的单方向的密钥，
而从服务器到浏览器也有另一个密钥
there's one key from browser to server,
and there's a separate key from server to

10
00:00:40,087 --> 00:00:44,774
所以发送信息从浏览器到服务器，用一个密钥
browser. So one key is used for sending
messages from a browser to the server, and

11
00:00:44,774 --> 00:00:49,113
发送信息从服务器到浏览器，用另一个密钥
the other key is used from sending
messages from the server to the browser,

12
00:00:49,113 --> 00:00:53,800
当然，服务器和浏览器双方都知道这些密钥
and of course both sides, both the server
and the browser, know both of these keys.

13
00:00:53,800 --> 00:00:58,026
为了更清楚，我说浏览器会使用这个密钥来发送数据
And just to be clear I'll say the browser
will use this key to send data to the

14
00:00:58,026 --> 00:01:02,464
给服务器，我们会使用这个密钥来读取从服务器发来的数据
server and we'll use this key to read data
from the server and the server basically

15
00:01:02,464 --> 00:01:06,638
而服务器用另一方向的密钥来做一模一样的事情
does exactly the same thing just with the
opposite keys. Now these keys, both of

16
00:01:06,638 --> 00:01:10,811
双方向的密钥都是由TLS密钥交换协议生成的
these keys are actually generated by the
TLS key exchange protocol which we're

17
00:01:10,811 --> 00:01:15,143
我们将在本课程的第二部分讨论之。现在我假设
gonna talk about in the second part of the
course. Right now I'm gonna assume that

18
00:01:15,143 --> 00:01:19,529
这些密钥已经被建立了。服务器和浏览器都知道这些密钥
these keys have already been established.
They're known to both the server and the

19
00:01:19,529 --> 00:01:23,859
现在浏览器和服务器想使用这些密钥来交换信息
browser, and now the browser and server
want to exchange information using those

20
00:01:23,859 --> 00:01:27,591
TLS记录协议使用了所谓的基于状态的加密
keys. So the TLS record protocol uses
what's called stateful encryption, which

21
00:01:27,591 --> 00:01:31,693
意思是，每个数据包的加密是使用
means that the encryption of every packet
is done using certain state that's

22
00:01:31,693 --> 00:01:36,575
浏览器和服务器内部维护的特定状态来完成的
maintained inside of the browser and the
server. In particular the state that's of

23
00:01:36,575 --> 00:01:41,368
特别地，我们感兴趣的状态是这些64位计数器
interest to us are these 64 bit counters,
again there are two 64 bit counters. One

24
00:01:41,368 --> 00:01:45,483
一个用于从浏览器到服务器的通信，
另一个用于从服务器到浏览器的通信
for traffic from browser to server, and
one from traffic from the server to the

25
00:01:45,483 --> 00:01:49,286
当会话被首次初始化后，这些计数器被初始化为0
browser. These counters are initialized to
zero when the session is first

26
00:01:49,286 --> 00:01:53,558
然后每次发送记录时，它们都增加
initialized, and they're incremented every
time a record is sent. So every time the

27
00:01:53,558 --> 00:01:57,830
每次浏览器发送一个记录给服务器时，浏览器都会增加这个计数器
browser sends a record to the server, the
browser will go ahead and increment this

28
00:01:57,830 --> 00:02:01,893
当服务器收到这个记录时，它会增加它这边的计数器
counter. When the server receives that
record, it'll go ahead and increment the

29
00:02:01,893 --> 00:02:06,086
当服务器发送记录给浏览器时
counter on its side. And when the server
sends a record to the browser, he'll go

30
00:02:06,086 --> 00:02:10,454
它会增加第二个计数器，当浏览器接收到这个记录时
ahead and increment the second counter and
again when the browser receives this

31
00:02:10,454 --> 00:02:14,931
它会增加它这边的计数器
record it'll go ahead and increment its
copy of this counter. So this state these

32
00:02:14,931 --> 00:02:19,463
一个状态，两个计数器。这个状态存在于浏览器和服务器双方
two counters basically this state exists
both on the browser and on the server and

33
00:02:19,463 --> 00:02:23,940
随着记录由一方发送，另一方接收，状态被合理地更新
it's updated appropriately as records as
sent from one to the other and received

34
00:02:23,940 --> 00:02:28,363
现在这些计数器的目的，我们一会将看到
by the appropriate side. Now the purpose
of these counters as we'll see in just a

35
00:02:28,363 --> 00:02:32,840
是为了阻止重放攻击，这样攻击者不能简单地保存记录
minute is to prevent replay attacks so
than an attacker can't simply record the record

36
00:02:32,840 --> 00:02:37,044
然后待会再重放，因为到时候计数器一定已经增加了
and then replay at a later time because by
then the counters will have to be

37
00:02:37,044 --> 00:02:41,990
我们看记录协议的工作细节
incremented. Okay, so let's look at the
details of how the record protocol works.

38
00:02:41,990 --> 00:02:47,304
特别地，我要为大家展示这个强制性的密码套件
In particular I'll show you kind of the
mandatory cipher suit which is encryption

39
00:02:47,304 --> 00:02:52,508
加密使用AES-CBC，MAC使用HMAC-SHA1。
记住TLS使用了一个MAC，然后加密
using AES-CBC and MACing using HMAC-SHA1. Okay,
so remember, TLS uses a MAC, then encrypt,

40
00:02:52,508 --> 00:02:56,825
MAC算法是HMAC-SHA1
where the MAC algorithm is HMAC-SHA1, and the encryption

41
00:02:56,825 --> 00:03:02,043
加密算法是AES128用CBC模式。我们看浏览器给服务器发送数据
algorithm is AES128 in CBC mode. Okay, so
let's look at how the browser sends data

42
00:03:02,043 --> 00:03:07,068
我说过，使用的是从浏览器到服务器的密钥
to the server, which, as I said, is done
using the browser to server key. Now, the

43
00:03:07,068 --> 00:03:12,218
从浏览器到服务器的密钥本身，是由一个MAC密钥
和一个加密密钥组成
browser to server key itself, is made up
of a MAC key and an encryption key. Two

44
00:03:12,218 --> 00:03:18,436
如我所说，两个单独的密钥在会话起始阶段就被协商好了
separated keys that are again as I said
negotiated during session setup. And again

45
00:03:18,436 --> 00:03:22,889
我想说的绝对清楚。从浏览器到服务器有一个单独的密钥
I wanna be absolutely clear. There is a
separate key for browser to server and a

46
00:03:22,889 --> 00:03:27,176
从服务器到浏览器有另一个单独的密钥。所以
总的来说，一共有4个密钥
separate key from server to browser. So
there, overall, there are four keys. Two

47
00:03:27,176 --> 00:03:31,406
两个是MAC密钥，两个是加密密钥，每个被使用在合适的方向
MAC keys, and two encryption keys, each
one used in the appropriate direction.

48
00:03:31,406 --> 00:03:36,026
这里我写下了TLS数据包的结构图
Okay, so here I wrote down the diagram of
what a TLS packet looks like. It begins

49
00:03:36,026 --> 00:03:40,368
它以一个报文头开头，包含了数据包的类型、协议版本号
with a header that contains the type of
the packet, the version number for the

50
00:03:40,368 --> 00:03:44,766
以及数据包的长度。注意到数据包的长度
protocol, and the length of the packet.
Notice the length of the packet it sends

51
00:03:44,766 --> 00:03:49,316
是以明文形式发送的。加密数据、加密特定记录时
in the clear. Now, when the encrypting
data, a certain record, the encryption

52
00:03:49,316 --> 00:03:54,083
加密流程如下：当然，取密钥为输入
procedure works as follows. Of course, it
takes key as input, and it takes the

53
00:03:54,083 --> 00:03:59,139
取当前状态为输入，然后如下工作。
current status input. And then it works as
follows. What it'll do is first of all

54
00:03:59,139 --> 00:04:03,851
首先它会计算下面数据的MAC，这是取MAC的实际的封装数据
it would MAC the following data, while
here's the actual payload that's MACed but

55
00:04:03,851 --> 00:04:08,679
不过报文头也在MAC的计算中，另外，计数器的当前值
the header is also MACed. In addition the
counter, the current value of the counter

56
00:04:08,679 --> 00:04:12,926
也在MAC的计算中，当然，所有计数器增加
is also MACed and of course, it's all the
counters are incremented to indicate

57
00:04:12,926 --> 00:04:17,754
以表示又一个记录被发送了。这里有趣的是
the fact that one more record has
been sent. Now the interesting thing here

58
00:04:17,754 --> 00:04:22,271
即使计数器的值包含在标签里
is that even though the value of the
counter is included in the tag. You notice

59
00:04:22,271 --> 00:04:26,356
大家注意，计数器的值实际上永远不会在记录中发送
the value of the counter is actually never
sent in the record, and the reason it

60
00:04:26,356 --> 00:04:30,593
它不用被放在记录里发送的原因是，另一端的服务器
doesn't need to be sent in the record is
that the server on the other side already

61
00:04:30,593 --> 00:04:34,729
已经知道了计数器的值，所以它不需要
knows what the value of the counter needs
to be. So it doesn't need to be told in

62
00:04:34,729 --> 00:04:38,814
在记录中被告知计数器的值，它隐性地知道这个值
the record what the value of the counter
is. It implicitly already knows what it

63
00:04:38,814 --> 00:04:42,949
当它要验证这个MAC时，它可以使用它认为的计数器的值
is, and when it's gonna verify the MAC, it
could just use the value that it thinks

64
00:04:42,949 --> 00:04:47,072
来验证这个MAC。这是个有趣的方法
the counter should be and verify the MAC
in that fashion. Okay, so this is kind of

65
00:04:47,072 --> 00:04:51,315
尽管双方都维护着这些计数器
an interesting approach, where even though
the two sides maintain these counters that

66
00:04:51,315 --> 00:04:55,406
这些计数器具备新鲜值的功能，
没有理由把新鲜值放在记录里
function as nonces, there is no
reason to send the nonces in the record,

67
00:04:55,406 --> 00:04:59,397
因为双方实际上都知道每个收到的记录的计数器
because both sides actually already know
what counters they're expecting every

68
00:04:59,397 --> 00:05:04,024
那么这是标签。我们说过，这个标签计算的范围
record that they receive. Okay, so that's
the tag. The tag is computed, as we said,

69
00:05:04,024 --> 00:05:09,320
是这个三元组数据。下件事是把标签附在数据后面
over this triple data. The next thing that
happens is that the tag is concatenated to

70
00:05:09,320 --> 00:05:13,930
记着，这是先MAC后加密。所以这里我们计算了MAC
the data. Remember, this is MAC-then-Encrypt. So here, we computed the MAC. Now

71
00:05:13,930 --> 00:05:18,852
我们会将数据和标签一并加密。所以报文头、数据
we're gonna encrypt the data along with
the tag. So the header, the data, and the

72
00:05:18,852 --> 00:05:23,649
和标签被补齐到AES分组。我想我们说过这种补齐了
tag are padded to the AES block, and I
think we already said that this pad, if

73
00:05:23,649 --> 00:05:28,696
如果补齐的长度是5个字节，那么补齐就是简单地
the pad length is five, then the pad is
done by simply writing the byte five, five

74
00:05:28,696 --> 00:05:34,032
写5个5。如果补齐长度是5个字节，补齐将是55555
times. If the pad length is to be 5, the
pad would just be 55555. And then we CBC

75
00:05:34,032 --> 00:05:39,477
然后我们用加密密钥来进行CBC加密，我们计算
数据和标签的CBC加密
encrypt using the encryption key, we CBC
encrypt the data and the tag. And we do

76
00:05:39,477 --> 00:05:44,715
我们使用一个新鲜的随机IV，它待会被嵌入到密文中
that using a fresh random IV, which is
later embedded in the cipher text. And

77
00:05:44,715 --> 00:05:50,367
然后我们在结果前附上报文头、报文类型、版本号和长度
then we prepend the header, the type,
the version and the length. And that gives

78
00:05:50,367 --> 00:05:55,802
这就给出了整个TLS记录，然后发送给服务器
us the entire TLS record, which is then
sent over to the server. So the grayed out

79
00:05:55,802 --> 00:06:00,231
结构图中灰色的区域对应于被加密的数据
fields in this diagram correspond to
encrypted data, and the white fields

80
00:06:00,231 --> 00:06:05,146
白色的区域对应于明文数据。所以大家可以看到
这是TLS的"先MAC后加密"的实现
correspond to plaintext data. So you can
see that this is TLS's implementation of

81
00:06:05,146 --> 00:06:10,121
唯一与"先MAC后加密"的区别在于
MAC then encrypt. The only difference from
basic MAC then encrypt is the fact that

82
00:06:10,121 --> 00:06:14,915
有一个状态，即这个计数器，被包含在MAC值里
there is a state, namely this counter is
being included in the value of the MAC.

83
00:06:14,915 --> 00:06:19,852
我也说过，这是为了阻止重放攻击。我们来看为什么能阻止重放
And again as I said that's done to prevent
replays. So let's see why that prevents

84
00:06:19,852 --> 00:06:24,430
特别地，我们看记录协议是如何解密到来的记录
replays. In particular, let's see how the
record protocol decrypts an incoming

85
00:06:24,430 --> 00:06:28,829
那么，这里来了一个加密的记录
record. So, here comes an incoming
encrypted record. And again, the server is

86
00:06:28,829 --> 00:06:33,763
服务器又将使用对应的、从浏览器到服务器的密钥
going to use its own key that corresponds
to data, from browser to server. And its

87
00:06:33,763 --> 00:06:38,222
以及从浏览器到服务器的计数器。首先
own browser to server counter. And the
first thing it's going to do, is it's

88
00:06:38,222 --> 00:06:42,681
我们使用加密密钥来解密记录。解密后，
going to decrypt the record using the
encryption key. After <b><font color="red">encryption</font></b>, it's
(口误：encryption->decryption)

89
00:06:42,681 --> 00:06:47,318
检测补齐长度，换句话说，如果补齐长度是5字节
going to check the format of the pad. In
other words, if the pad length is five

90
00:06:47,318 --> 00:06:51,826
检查结尾是否真是55555
bytes, it's going to check that it really
is five, five, five, five, five. And if

91
00:06:51,826 --> 00:06:56,124
如果不是，它将发送一个坏记录MAC警告
it's not, it's gonna send a bad record MAC
alert message and terminate the

92
00:06:56,124 --> 00:07:01,061
并断开连接。如果需要发送更多记录，
那就必须协商一个新的会话密钥
connection. So that a new session key will
have to be negotiated if more records need

93
00:07:01,061 --> 00:07:05,935
如果补齐格式是正确的，去除补齐是很容易的
to be sent. If the pad format is correct,
then removing the pad is really easy. All

94
00:07:05,935 --> 00:07:10,595
服务器只需看补齐的最后的字节，比如说
the server does is it looks at the last
byte of the pad, say the last byte is

95
00:07:10,595 --> 00:07:15,254
最后一个字节等于5，那么它就去除记录的最后5个字节
equal to five, and, then, it removes the
last five bytes of the record. By doing

96
00:07:15,254 --> 00:07:20,216
这就去除补齐了。接下来从记录中提取标签
that it strips off the pad. The next thing
it's gonna do is it's gonna extract the

97
00:07:20,216 --> 00:07:25,117
这里网页数据藏在这个记录里
tag from the record. So, this would be the
web sequence bytes inside of the record.

98
00:07:25,117 --> 00:07:30,079
也就是我去除补齐后剩下的记录
So, this would be the, the trailing bytes
in the record after we remove the pad, and

99
00:07:30,079 --> 00:07:34,860
然后会验证报文头、数据和计数器值的标签
then it's gonna verify the tag on the
header, the data and its value of counter.

100
00:07:34,860 --> 00:07:39,809
如果MAC不能验证，将发送一个警告，坏记录MAC
And if the MAC doesn't verify again, it's
gonna send an alert, bad record MAC, and

101
00:07:39,809 --> 00:07:44,634
然后断开连接。如果标签通过验证，就去除标签
tear down the connection. And if the <b><font color="red">pad</font><b>
does verify, it's gonna remove the tag,
(这里pad应该为tag)

102
00:07:44,634 --> 00:07:49,460
去除报文头，剩下的记录是明文数据
remove the header, and the remaining part
of the record is the plain text data

103
00:07:49,460 --> 00:07:54,693
也就是给应用的数据。现在，大家可以看到如果记录被重放了
that's given to the application. Now, you
can see if a record is ever replayed, in

104
00:07:54,693 --> 00:07:59,980
换句话说，如果攻击者记下了某个记录，
other words if an attacker records a
particular record and then replays it to the

105
00:07:59,980 --> 00:08:05,402
然后稍后重放它给服务器，到时候计数器的值已经变了
server at a later time, then, by then the
value of the counter would have changed

106
00:08:05,402 --> 00:08:11,028
因此被重放的记录的标签将不会通过验证
and as a result the tag on the replayed
record would simply not verify because the

107
00:08:11,028 --> 00:08:16,451
因为这个标签的计算使用了计数器的值
tag was computed using one value of the
counter but with the replayed record as

108
00:08:16,451 --> 00:08:21,285
但对于重放的记录来说，被服务器收到后，计数器的值
received at the server, the value of the
counter of the server is different from

109
00:08:21,285 --> 00:08:25,996
已经和计算记录里的标签时的计数器值不一样了，
因此这个标签将不会通过验证
the value that was used to compute a tag
and as a result the tag was not verified.

110
00:08:25,996 --> 00:08:30,536
这些计数器很优雅，简单地阻止了重放攻击
So these counters are very elegant and
simple way for preventing replays and the

111
00:08:30,536 --> 00:08:35,018
这样做很好的一点是，因为双方都隐性地知道
nice thing about this is because both
sides know the value of the counter implicitly

112
00:08:35,018 --> 00:08:39,499
计数器的值，记录中永远不需要发送计数器了
there's never a need to send the
counter in the record itself. So the

113
00:08:39,499 --> 00:08:43,787
所以计数器本身并不增加密文L的长度
counter itself doesn't increase the length
of cipher text L. Now, we already

114
00:08:43,787 --> 00:08:48,692
现在，我们已经提到过这个方法用来认证加密
mentioned that this particular approach
to, authenticated encryption, namely, MAC,

115
00:08:48,692 --> 00:08:53,358
先MAC，然后使用CBC加密，事实上是认证加密
then encrypt, using CBC encryption, is, in
fact, authenticated encryption. However,

116
00:08:53,358 --> 00:08:57,904
不过它只有当解密时没有信息泄漏，才是认证加密
it's only authenticated encryption if no
other information is leaked during

117
00:08:57,904 --> 00:09:02,211
我们将看到一些犀利的针对TLS的攻击
decryption. And we're going to see some
acute attacks on TLS if there is

118
00:09:02,211 --> 00:09:06,398
针对解密时有信息泄漏的情况。我应该说
information being leaked during
decryption. I should say that this bad

119
00:09:06,398 --> 00:09:11,363
这个坏记录MAC警告对应于解密算法输出
record MAC alert basically corresponds to
the decryption algorithm outputting this

120
00:09:11,363 --> 00:09:16,058
拒绝符号⊥，意思是密文是无效的
reject symbol, the bottom symbol. Meaning
that the cipher text is invalid. And as

121
00:09:16,058 --> 00:09:20,550
只要无法区分为什么密文被拒绝了
long as there's no way to differentiate
between why the cipher text was rejected,

122
00:09:20,550 --> 00:09:25,152
换句话说，解密者暴露了拒绝的事实
in other words the decrypter only exposes
the fact that a rejection took place but

123
00:09:25,152 --> 00:09:29,311
但它不说为什么会拒绝。事实上这是一个认证加密系统
it doesn't say why the rejection happened
this is in fact an authenticated

124
00:09:29,311 --> 00:09:33,300
但是，如果区分和暴露了为什么
encryption system. However, if you
differentiate and expose why the cipher

125
00:09:33,304 --> 00:09:37,907
密文会被拒绝，是否是因为坏的补齐，
抑或是因为坏的MAC
text was rejected whether it was because
of a bad pad or because of a bad MAC then

126
00:09:37,907 --> 00:09:42,510
那么就会有一个非常犀利的攻击，
我们将在下一节看到它
it turns out there's a very acute attack.
Which we're gonna see in the next segment.

127
00:09:42,510 --> 00:09:47,402
目前我给大家展示了TLS 1.1版本
What I showed you so far is called TLS
Version 1.1. It turns out that earlier

128
00:09:47,402 --> 00:09:52,231
实际上在这之前的TLS版本有严重的错误
versions of TLS actually had significant
mistakes in it, and as a result, the

129
00:09:52,231 --> 00:09:57,441
较早的记录协议对很多攻击是脆弱的
earlier Record Protocol is vulnerable to a
number of attacks. The first mistake is

130
00:09:57,441 --> 00:10:02,397
第一个错误是CBC加密使用的IV是可以预测的
that the IV used in CBC Encryption is
predictable. And we said earlier that in

131
00:10:02,397 --> 00:10:07,099
我们之前说过在CBC里，如果IV是可预测的，
那么会造成CBC加密不是CPA安全的
CBC, if the IV is predictable then the
resulting CBC Encryption is not CPA

132
00:10:07,099 --> 00:10:11,928
在较早版本的TLS里，TLS 1.0或更早
Secure. Well, in this older version of
TLS, TLS 1.0 and earlier, the IV for the

133
00:10:11,928 --> 00:10:16,921
下一记录所用的IV就是当前记录的最后一个密文分组
next record is simply the last cipher text
block of the current record. And as a

134
00:10:16,921 --> 00:10:21,200
因此，如果攻击者可以观察到当前的记录
result, if the adversary can observe the
current record, he knows the IV for the

135
00:10:21,200 --> 00:10:25,426
他就会知道下一记录的IV，这就允许他破坏
下一个记录的语义安全
next record and that will allow him to
break the semantic security of the next

136
00:10:25,426 --> 00:10:29,866
得到的机制不是CPA安全的。它不仅不是CPA安全的
record. So the resulting scheme is not CPA
secure. But not only is it not CPA secure,

137
00:10:29,866 --> 00:10:34,146
事实上，有一个非常系里的攻击叫做BEAST攻击
in fact, there is a very acute attack
called a BEAST attack that's able to decrypt

138
00:10:34,146 --> 00:10:38,425
可以解密TLS记录的最初部分
the initial part of the TLS record
simply based on the fact that this scheme

139
00:10:38,425 --> 00:10:43,206
因为TLS这个机制不是语义安全的。我应该说
这种选前一个记录的最后一个分组为IV的方法
is not semantically secure. So, I should
say that this method of choosing the IV to

140
00:10:43,206 --> 00:10:47,999
叫做链式IV。大家应该记住
be the last block of the previous record
is called chained IV's. And you should

141
00:10:47,999 --> 00:10:53,095
这种方法不应在实际中使用
remember that this, actually should not be
used in practice because it always, always

142
00:10:53,095 --> 00:10:57,948
因为它总是会造成攻击。正因为此，
TLS 1.1改用了所谓的显性IV
leads to an attack. Because of this TLS
1.1 moved to what's called, explicit IV's

143
00:10:57,948 --> 00:11:02,801
其中每个TLS记录有它自己的随机的不可预测的IV
where every TLS record has its own random
unpredictable IV. And that's fixed the

144
00:11:02,801 --> 00:11:07,776
一旦浏览器和服务器升级到了TLS 1.1，问题就会解决
problem as soon as browsers and servers
move to TLS 1.1, this will no longer be an

145
00:11:07,776 --> 00:11:11,993
TLS 1.0以及更早版本的另一个错误是
issue. Now another mistake that was done
in TLS 1.0 and earlier, enabled what's

146
00:11:11,993 --> 00:11:15,954
采用了所谓的补齐神谕，我们下节再讨论它
called a padding oracle, which is
something that we're going to talk about

147
00:11:15,954 --> 00:11:20,182
如果密文因为补齐无效而被拒绝了
in the next segment, were what happened
was, that if the cipher text was rejected

148
00:11:20,182 --> 00:11:24,683
服务器会发送一个警告说，加密失败
due to an invalid pad, the server was sent
back an alert message saying decryption

149
00:11:24,683 --> 00:11:29,113
同时，如果密文是因为错误的MAC而被拒绝
failed. Whereas if the cipher text was
rejected due to a bad MAC, the server will

150
00:11:29,113 --> 00:11:33,267
服务器会发送一个坏记录MAC警告。因此
send back a bad record MAC alert. As a
result, and adversary who observes the

151
00:11:33,267 --> 00:11:37,753
攻击者观察这些服务器返回的警告，就可以得知
密文的补齐是否是有效的
alert sends back from the server, can tell
whether the pad in the cipher text was

152
00:11:37,753 --> 00:11:42,184
这样引入了一个非常重要的攻击叫做补齐攻击
valid or invalid. And this introduces a
very significant attack called a padding

153
00:11:42,184 --> 00:11:46,670
我们下节讨论之。TLS 1.1对此的解决方法是
attack, which we're gonna talk about in
the next segment. The solution to this and

154
00:11:46,670 --> 00:11:50,713
不再报告解密失败
TLS 1.1, was basically to say that,
instead of reporting decryption failed

155
00:11:50,713 --> 00:11:55,092
而是报告一个坏MAC，即使补齐是错误的
here, we're gonna report a bad record MAC,
even if the pad is incorrect. And, as a

156
00:11:55,092 --> 00:11:59,445 
因此，通过简单地看服务器返回的是哪种警告
result, simply looking at which alert is
sent back from the server, an attacker

157
00:11:59,445 --> 00:12:04,121
攻击者不能识别，密文的被拒绝，是因为坏补齐还是坏MAC
can't tell if a cipher text is rejected
because of a bad pad or a bad MAC. So this

158
00:12:04,121 --> 00:12:09,354
这就隐藏了这个信息。这里的教训是
tries to mask this information. Now the
lesson from this is that when decryption

159
00:12:09,354 --> 00:12:14,156
当解密失败时，永远不要解释为什么。
我猜老TLS版本这样设计，可能是来自
fails, you should never ever explain why,
I guess this is something that comes out

160
00:12:14,156 --> 00:12:19,135
网络协议里的惯例：如果发生失败的情况，
就想告诉对方为什么会失败
of networking protocols where if there is
a failure you wanna tell the peer why the

161
00:12:19,135 --> 00:12:24,114
但在密码学里，如果你解释为什么会失败
failure occurred, where in cryptography if
you explain why the failure occurred that

162
00:12:24,114 --> 00:12:28,797
很可能会造成一个攻击。换句话说，当解密失败时
very often leads to an attack. In other
words when decryption fails just output

163
00:12:28,797 --> 00:12:33,540
只输出拒绝，从不解释为什么拒绝，光拒绝就行了
reject and don't explain why the reject
actually happens just reject the ciphertext.

164
00:12:33,860 --> 00:12:38,462
现在我们已经看了TLS 1.1。我们再看一个已被破解的协议
Okay, so now that we've seen TLS 1.1,
let's see a broken protocol. So of course

165
00:12:38,462 --> 00:12:43,363
当然我总是喜欢拿802.11b WEP开刀，这个WEP里
几乎所有的东西都不对
I always like to pick on 802.11b WEP,
which pretty much got everything wrong. So

166
00:12:43,363 --> 00:12:48,086
我们看它是如何不能提供认证加密的
let's see how not to provide authenticated
encryption. So let me remind you how

167
00:12:48,086 --> 00:12:52,808
我帮大家看一下802.11b WEP是如何工作的。
笔记本想发送一条信息给接入点
802.11b WEP works. Basically there's a
message that the laptop wants to send to

168
00:12:52,808 --> 00:12:57,410
首先，笔记本计算信息的循环冗余校验码(CRC)
the access point. The first thing that
happens is it, the laptop computes a

169
00:12:57,410 --> 00:13:02,371
然后把CRC校验码附在信息的后面
cyclic redundancy checksum on the message
and concatenates the CRC checksum to the

170
00:13:02,371 --> 00:13:06,937
然后结果用流密码加密，流密码用的是RC4
message. Then the result is encrypted
using a stream cipher, in particular RC4.

171
00:13:06,937 --> 00:13:12,067
大家回忆一下，WEP使用的密钥是一个初始IV值
If you recall, the key that's used is the
concatenation of an initial value IV

172
00:13:12,067 --> 00:13:17,263
这个IV每个数据包都会变，再联结上一个长密钥K
that changes per packet and the long term
key K. And then the IV along with the

173
00:13:17,263 --> 00:13:21,506
然后IV和密文一并传递给对方。现在我们已经看了
cipher text are transmitted to the other
side. Now we've already saw two

174
00:13:21,506 --> 00:13:26,089
这种方法的两个问题。一个是IV会重复
problems with this approach. One was if
the IV is ever repeated and in fact it is

175
00:13:26,089 --> 00:13:30,954
事实上这个IV一重复，那你就能实施一个二次密码本攻击
gonna be repeated then you get a two time
pad attack. And the other problem

176
00:13:30,954 --> 00:13:35,310
另一个问题是WEP使用了关联非常密切的密钥。换句话说
is that WEP uses very closely
related keys. In other words, the key is

177
00:13:35,310 --> 00:13:39,949
密钥仅仅是IV联结上K，唯一改变的是IV
simply IV concatenated to K and the only
thing that changes are the IV so the key

178
00:13:39,949 --> 00:13:44,475
而密钥K总是固定的，这意味着这些PRG密钥互相之间
is always fixed, which means that these
PRG keys are very closely related to one

179
00:13:44,475 --> 00:13:48,831
关系非常紧密。我们说过，这里使用的PRG是RC4
another and as we said, the PRG that's
used here, RC4 is not designed for this

180
00:13:48,831 --> 00:13:53,524
RC4不是为这种用法而设计的，他会完全被破解，
如果你使用关联密钥
type of use and it completely breaks
if you use it with related keys, and as a

181
00:13:53,524 --> 00:13:58,110
因此WEP根本没有安全性可言。我想为大家展示
result WEP has no security at all.
What I want to show you is that even the

182
00:13:58,110 --> 00:14:02,332
这里甚至使用了CRC机制，以试图提供完整性
CRC mechanism that's used here, in an
attempt to provide integrity and prevent

183
00:14:02,332 --> 00:14:05,872
想阻止攻击者篡改密文
an adversary from tampering with the
cipher text, even that mechanism is

184
00:14:05,872 --> 00:14:09,960
即便这个机制被完全破解了，
实际上在途中篡改密文也极为容易
completely broken, and it's actually very
easy to tamper with cipher texts en route.

185
00:14:09,960 --> 00:14:14,935
我们看看怎么做。这个攻击利用了CRC校验和的一个性质
So let's see how that's done. The attack
uses a particular property of the CRC

186
00:14:14,935 --> 00:14:20,399
CRC基本上是线性的，意思是如果我给你信息M的CRC校验码
check sum. Mainly the CRC is linear. What
that means is if I give you CRC of M, and

187
00:14:20,399 --> 00:14:25,525
我让你计算M异或P的CRC，那么这是容易做到的
I ask you to compute CRC of M XOR P, then
it's very easy to do. Basically you'll

188
00:14:25,525 --> 00:14:30,989
你只要计算某个广为人知的函数F(P)，再把这两结果异或
just compute some well known and public
function of F(P), you XOR these two together,

189
00:14:30,989 --> 00:14:35,976
就得到了M异或P的CRC。某种意义上
and that in fact will give you CRC of
M XOR P. So in some sense the XOR comes out

190
00:14:35,976 --> 00:14:40,380
这里的异或从括号里提取出来了，意味着CRC是线性的
of the parenthesis, and that basically
means the CRC is linear. Now here is how the

191
00:14:40,380 --> 00:14:44,727
攻击如下。假设攻击者截获了某个数据包
attack works, suppose the adversary
intercepts a particular packet that's

192
00:14:44,727 --> 00:14:48,841
送往接入点的数据包。现在数据包说
destined to the access point. Now the
packet say, sais it's destined for

193
00:14:48,841 --> 00:14:53,535
它的目标端口是80，攻击者知道它是送往80端口的
destination port 80, and the attacker
knows that it's intended for destination

194
00:14:53,535 --> 00:14:58,114
攻击者想修改密文
port 80 and what he wants to do is
modify the cipher texts such that now the

195
00:14:58,114 --> 00:15:02,550
使得目标端口变成25，而不是80
destination port will say 25 instead of
80. And maybe the attacker can read

196
00:15:02,550 --> 00:15:06,922
也许攻击者可以读取送往25端口的信息，
这样他就能获取数据包里的数据了
messages for port 25 and that's how he
actually obtains the actual data in the

197
00:15:06,922 --> 00:15:11,405
记得CRC校验和是为了确保攻击者不能修改密文中的数据
packet. So recall that the CRC checksum
is there to make sure that exactly the

198
00:15:11,405 --> 00:15:15,943
但是我想告诉大家，事实上
attacker cannot change data inside of the
cipher text. But I want to show you that

199
00:15:15,943 --> 00:15:20,702
非常容易修改密文数据
in fact it's really easy to modify data in
the cipher text and CRC basically provides

200
00:15:20,702 --> 00:15:25,611
CRC对篡改根本没有安全可言。我们看怎么做
no security against tampering at all. So
let's see how to do it. Well, what the

201
00:15:25,611 --> 00:15:31,549
攻击者会对密文中代表80的那些字节
attacker would do is, he would basically
XOR some, a certain value XX into the byte

202
00:15:31,549 --> 00:15:37,130
异或某些特定的值XX。现在他会异或
that represents the eight zero in the
cipher text. Now what he'll XOR in will

203
00:15:37,130 --> 00:15:43,497
字符串25异或80，大家记得，如果我异或特定字符串XX
basically be the string 25 XOR 80 and you
remember that if I XOR a certain string XX

204
00:15:43,497 --> 00:15:48,890
到密文里，密文由流密码生成
into the cipher text. That was created
using a stream cipher. When that cipher

205
00:15:48,890 --> 00:15:54,653
当密文解密时，此处的明文也会变成异或了XX后的样子
gets, is decrypted, the plain text at this
position will also be XORed by XX. And as

206
00:15:54,653 --> 00:16:00,176
因此在解密后，此处的明文会变成
a result after decryption the plain text
at this position basically will be the

207
00:16:00,176 --> 00:16:05,767
原文80异或25异或80=25。所以在解密后
original 80 XOR 25 XOR 80 which gives us 25.
Okay? So after decryption the plain text

208
00:16:05,767 --> 00:16:11,152
这里的明文变成了25。问题是，如果我们只做这些
of this position will now be 25. The
problem is that if that's all we did then

209
00:16:11,152 --> 00:16:16,537
攻击还是会失败的，因为CRC校验和现在还不是有效的
this attack would fail because the CRC
check sum would now would not validate.

210
00:16:16,537 --> 00:16:21,672
这里的CRC校验和是根据"80端口"的明文构建的，
但"25端口"是一个不同的明文
The CRC check sum was built with 80 as a
plain text but 25 is a different plain

211
00:16:21,672 --> 00:16:26,883
需要一个不同的CRC。但这不是问题，因为
text and needs a different CRC. But it's
not a problem because what we can do is we

212
00:16:26,883 --> 00:16:31,969
我们可以轻松修正这个CRC校验码，尽管CRC校验码也被加密了
can easily correct the check sum, the CRC
check sum, even though the CRC check sum

213
00:16:31,969 --> 00:16:37,180
我们把密文中对应CRC校验码的部分
is encrypted. What we do is we XOR
F of XX into the cipher text at the place

214
00:16:37,180 --> 00:16:42,266
与F(XX)异或，所以当密文解密后
where the CRC is supposed to be and as a
result, when the cipher text is decrypted

215
00:16:42,266 --> 00:16:47,271
我们会得到正确的CRC校验和
what will happen is we'll get the correct
CRC check sum after decryption. So, the

216
00:16:47,271 --> 00:16:52,275
这里有趣的事情是，尽管攻击者不知道
interesting thing that happened here is
even though the attacker doesn't know what

217
00:16:52,275 --> 00:16:57,157
CRC校验和是什么，他依然可以利用CRC的线性性质进行修正
the CRC value is, he's able to correct it
using this linearity property such that

218
00:16:57,157 --> 00:17:01,738
使得当密文解密时，明文中的CRC校验和是正确的
when the cipher text is decrypted the
correct CRC value appears in the plain

219
00:17:01,738 --> 00:17:06,671
所以CRC的线性性质在这个攻击中扮演着重要角色
text. Okay? So the linearity property of
CRC plays a critical role in making this

220
00:17:06,671 --> 00:17:11,483
结论是CRC校验和完全不提供完整性
attack works. The end conclusion here is
basically that a CRC check sum provides

221
00:17:11,483 --> 00:17:16,235
来对抗主动攻击，CRC永远不能用于完整性机制
absolutely no integrity at all against
active attacks and it should never, ever,

222
00:17:16,235 --> 00:17:20,686
如果你想提供完整性
ever be used as an integrity mechanism.
And instead if you want to provide

223
00:17:20,686 --> 00:17:25,318
你应该使用一个密码学MAC，而不是随意设计的机制
integrity you're supposed to use a
cryptographic MAC not an ad hoc mechanism

224
00:17:25,318 --> 00:17:29,353
比如CRC。现在我们已经看了认证加密
是如何在真实协议中实现的
like CRC. Okay, so now we've seen how
authenticated encryption is implemented in

225
00:17:29,353 --> 00:17:33,145
比如TLS。下节我们看
a real world protocol, like TLS. In the
next segment, we're gonna look at real

226
00:17:33,145 --> 00:17:37,287
针对认证加密实现的真实攻击
world attacks on authenticated encryption
implementations that happen to implement

227
00:17:37,287 --> 00:17:39,134
这些加密实现恰好是不正确的
authenticated encryption incorrectly.

1
00:00:00,000 --> 00:00:03,567
下面几节我们稍微变点讨论方向
In the next three segments we will change
gears a little bit and talk about the

2
00:00:03,567 --> 00:00:07,224
看看PRG的定义
这个定义是理解PRG的好方法
definition of a PRG. This definition is a
really good way to think of a PRG. And we

3
00:00:07,224 --> 00:00:10,784
我们可以看到这个定义的许多应用
will see many applications for this
definition. So consider a PRG with

4
00:00:10,784 --> 00:00:15,943
令PRG有密钥空间K，即N位字符串的集合
我们的目标是定义
keyspace K that ouputs N bit strings. Our
goal is to define, what does it mean for

5
00:00:15,943 --> 00:00:20,592
发生器输出与随机序列无法区分的意义
the output of the generator to be
indistinguishable from random? In other

6
00:00:20,592 --> 00:00:25,687
换句话说，我们要定义一个分布
从密钥空间里选择密钥时的分布
words, we're gonna define a distribution
that basically is defined by choosing a

7
00:00:25,687 --> 00:00:30,781
记得带R的箭头意思是
random key in the keyspace. Remember that
a arrow with R above it means choosing

8
00:00:30,781 --> 00:00:35,813
从集合K里均匀地随机选取
然后发生器的输出
uniformly from the set script K. And then
we output, basically, the output of the

9
00:00:35,813 --> 00:00:40,710
我们说这就是个分布
generator. And what we'd like to say. Is
that this distribution. This distribution

10
00:00:40,710 --> 00:00:44,757
这个伪随机字符串的分布
与真正的均匀分别没有分别
of pseudo random strings is
indistinguishable from a truly uniform

11
00:00:44,757 --> 00:00:49,927
换句话说，如果我们选择一个
均匀随机分布的N位0,1字符串
distribution. In other words, if we just
choose a truly uniform string in 01 to the

12
00:00:49,927 --> 00:00:55,096
输出该字符串，我们说这两个分布
N and simply output this string, we'd like
to say that these two distributions are

13
00:00:55,096 --> 00:01:00,139
是不能互相区分的，大家想想
indistinguishable from one another. Now if
you think about it, this sounds really

14
00:01:00,139 --> 00:01:05,246
这有点意外的，因为如果我们
画个圈表示所有N位0,1字符串
surprising because if we draw a circle
here of all possible strings in 01 to the

15
00:01:05,246 --> 00:01:10,541
那么均匀分布会以同等概率
输出这些字符串
N, then the uniform distribution basically
can output any of these strings with equal

16
00:01:10,541 --> 00:01:15,161
这是均匀分布的定义
probability. That's the definition of the
uniform distribution. However a

17
00:01:15,161 --> 00:01:20,661
不过这个发生器G生成的伪随机分布
pseudo-random distribution generated by
this generator G. Because the seed space

18
00:01:20,661 --> 00:01:25,673
因为种子空间太小，可能输出结果的集合
是很小很小的
is so small, the set of possible outputs
is really, really small, it's tiny inside

19
00:01:25,673 --> 00:01:30,623
是N位0,1字符串集合中一个很小的子集
这是发生器所能产生的一切
of, 01 to the N. And this is really all
that the generator can output. And yet,

20
00:01:30,623 --> 00:01:35,698
我们说，有个攻击者在观测发生器的输出
what we're arguing is that an adversary
who looks at the output of the generator

21
00:01:35,698 --> 00:01:40,836
也就是这个小集合里的元素，它与
均匀分布的输出无法区分
in this tiny set can't distinguish it from
the output of the uniform distribution

22
00:01:40,836 --> 00:01:45,703
我想这个性质就是我们想要的
over the entire set. I think that's the
property that we're actually shooting for.

23
00:01:45,703 --> 00:01:50,026
为了理解如何定义这个与真随机
不可区分的概念
So to understand how to define this
concept of indistinguishability from

24
00:01:50,026 --> 00:01:54,350
我们需要引入统计测试的概念
random, we need the concept of a
statistical test. So, let me define what a

25
00:01:54,350 --> 00:01:59,030
我来定义N位0,1字符串的统计测试
我用字母A来表示这些统计测试
statistical test on 01 to the N is. I'm
gonna define these statistical tests by

26
00:01:59,030 --> 00:02:03,924
统计测试是一个算法
the letter A. And the statistical test is
basically an algorithm that takes its

27
00:02:03,924 --> 00:02:08,486
以N位字符串为输入，输出0或1
inputs and N bit string, and simply
outputs zero or one. Now I'll tell you

28
00:02:08,486 --> 00:02:13,110
输出0，我们把它想象成统计测试说
that zero, we're gonna think of it as
though the statistical test said, the

29
00:02:13,110 --> 00:02:18,150
输入的字符串不是随机的
1的话我们可以想象成
input you gave me is not random. And one,
we're going to think of it as saying that

30
00:02:18,150 --> 00:02:23,196
测试结果认为输入字符串是随机的
好，统计测试所做的
the input you gave me actually is random.
Okay, so all this statistical test does is

31
00:02:23,196 --> 00:02:27,939
就是取输入x，即给定的n位字符串
it basically takes the input x that was
given to it, the n bit string that was

32
00:02:27,939 --> 00:02:32,803
然后判断它是否看起来像是随机的
given to it, and decides whether it looks
random or it doesn't look random. Let's

33
00:02:32,803 --> 00:02:37,849
我们看几个例子，第一个例子运用一个事实
look at a couple of examples. So the first
example basically will use the fact that

34
00:02:37,849 --> 00:02:42,835
那就是，对于一个随机字符串
0的个数和1的个数大体相等
for a random string, the number of zeros
is roughly equal to the number of ones in

35
00:02:42,835 --> 00:02:47,248
换句话说，统计测试输出1
that string. In other words, the
statistical test is going to say one. If

36
00:02:47,248 --> 00:02:54,514
当且仅当字符串X里0的个数减去1的个数
and only if basically the number of zeros
in the given string X minus the number of

37
00:02:54,514 --> 00:02:59,837
这些数不会差太多，换句话说
1's in the given string X. These numbers
are not too far apart. In other words, the

38
00:02:59,837 --> 00:03:05,225
0个数和1个数的差别
difference between the number of 0's and
the number of 1's. Let's just say is less

39
00:03:05,225 --> 00:03:10,614
比如说小于n的10倍平方根
好，如果差别小于n的10倍平方根
than ten times square root of n. Okay. If
the difference is less than ten times, the

40
00:03:10,614 --> 00:03:15,082
统计测试就会说字符串X像是随机的
statistical test will say hey the
string X looks random. If the

41
00:03:15,082 --> 00:03:20,602
如果比n的10倍平方根大得多
difference happens to be much bigger than
ten times square root of n, that starts to

42
00:03:20,602 --> 00:03:25,991
测试就会怀疑，觉得给的字符串
look suspicious and the test,
hey the string you gave me does not

43
00:03:25,991 --> 00:03:31,403
不像是随机的。这是一个统计测试
我们再看一个例子
look random. A statistical test. Let's
look at another similar example. We'll say

44
00:03:31,403 --> 00:03:36,785
统计测试说1，当且仅当字符串X中
here, the statistical test will say one.
If and only if say the number of times

45
00:03:36,785 --> 00:03:41,838
出现连续两个0的次数
that we have two consecutive zeros. Inside
of X. But let's think about this for a

46
00:03:41,838 --> 00:03:46,766
想一想，数一数，n位字符串中
second. This basically again counts. In
this string of, n bits. It counts a number

47
00:03:46,766 --> 00:03:51,734
数一数00出现的个数，连续两个0
of times that we see the pattern zero,
zero. Two consecutive zeros. Well for a

48
00:03:51,734 --> 00:03:56,804
对于一个随机字符串，我们期望
00的概率应该是四分之一
random string. We will expect to see 0,0
as probability one fourth. And there for

49
00:03:56,804 --> 00:04:03,535
对于一个随机字符串，我们期望
有大约N/4个00，对，N/4
in a random string. We'll expect about N
over four 0,0's. Yeah, N over four blocks

50
00:04:03,535 --> 00:04:08,133
那么这个统计测试会这么做
a 0,0. And so, what the statistical test
will do is it will say, well, if the

51
00:04:08,133 --> 00:04:12,604
如果00的个数大约是N/4，换句话说，
number of zero zeros is roughly N over
four. In other words, the difference

52
00:04:12,604 --> 00:04:17,254
00的个数与N/4的差别小于
n的10倍平方根
between the number and N over four,
is, say, less than ten square root of n,

53
00:04:17,254 --> 00:04:22,005
那我们就可说X像是随机的
如果这个差别远远大于N/4
then we will say that X looks random. And
if the gap is much bigger than N over

54
00:04:22,005 --> 00:04:26,309
那我们说字符串X不像是随机的
four, we'll say, hey, this string doesn't
really look random. And then the
(差别gap应为远远大于n的10倍平方根)


55
00:04:26,309 --> 00:04:31,097
然后统计测试就会输出0，对吧？
那么就是这两个统计测试的例子
statistical test will output zero, okay?
So here are two examples of statistical

56
00:04:31,097 --> 00:04:35,703
对于随机字符串，它们会以很大的概率
tests that basically, for random strings,
they will output one with very high

57
00:04:35,703 --> 00:04:40,067
输出1.对看起来不怎么随机的字符串
probability. But for strings that, you
know, don't look random, for example,

58
00:04:40,067 --> 00:04:44,856
比如全是0的字符串
think of the all zero string. So the all
zero string, neither one of these tests

59
00:04:44,856 --> 00:04:49,986
没有测试会输出1，事实上
全是0的字符串看起来不随机
will output, one. And in fact, the all
zero string does not look random. Let's

60
00:04:49,986 --> 00:04:55,098
我们再看一个统计测试的例子
look at one more example of the
statistical test just to kinda show you

61
00:04:55,098 --> 00:05:00,993
来为大家展示统计测试可以想怎么做
the, basically statistical test can pretty
much do whatever they want. So here's the

62
00:05:00,993 --> 00:05:06,745
看第三个例子。我们说统计测试输出1
third example. Let's say that statistical
test output one if an only if I say the

63
00:05:06,745 --> 00:05:12,497
当且仅当最大的块，我们叫0的最大游程
biggest blocks what we'll call this the
Maximum Run of zero inside of the string

64
00:05:12,497 --> 00:05:17,950
在字符串x中最长的连续的0
x, this is basically the longest sequence
of zero inside of the string x. In a

65
00:05:17,950 --> 00:05:23,336
在随机字符串里，我们期望
0的最长游程大约是
random string you expect the longest
sequence of zeros to be roughly of length

66
00:05:23,336 --> 00:05:28,449
log N。我们说如果0的最长游程
log N. So we'll say if the longest
sequence of zero happens to be less than
(2为底数)

67
00:05:28,449 --> 00:05:32,814
小于10log N，那么测试结果认为X是随机的
ten times log N. Then this test will say
that X was random. But if, all of a

68
00:05:32,814 --> 00:05:37,160
但如果有0的游程远远大于10log N
sudden, we see a run of zeros that, say,
is much bigger than ten log N, then the

69
00:05:37,160 --> 00:05:41,733
那么统计测试会说这个字符串不随机
statistical test will say, the string is
not random, okay? So this is another crazy

70
00:05:41,733 --> 00:05:46,192
对吧？这又是个统计测试的疯狂例子
顺便说下，注意到给定测试
thing that the statistical test will do.
By the way, you notice that if you give

71
00:05:46,192 --> 00:05:50,444
全是1的字符串1111..
this test, the all one string. So one,
one, one, one, one. This test will also

72
00:05:50,444 --> 00:05:55,370
这个测试也会输出1.换句话说这个测试
认为全是1的字符串也是随机的
output one. In other words this test will
think that the all one string is random.

73
00:05:55,370 --> 00:05:59,735
即使它不是，即使全1字符串不随机
Even though it's not. Yeah, even though
one string is not particularly random.

74
00:05:59,735 --> 00:06:04,068
好的，那么统计测试不一定总是对的
Okay, so statistical tests don't have to
get things right. They can do whatever

75
00:06:04,068 --> 00:06:08,149
它们可以想怎么来就怎么来
它们可以测试，判断、输出是否随机
they like. They can test, they can decide
to output random or not. You know, zero or

76
00:06:08,149 --> 00:06:11,776
也就是0或1，类似地还有许多其他统计测试
one, however they like. And similarly,
there are many, many, many, many other

77
00:06:11,776 --> 00:06:15,857
谁都可以造几百个统计测试出来
statistical tests. There are literally
hundreds of statistical tests that one can

78
00:06:15,857 --> 00:06:19,737
告诉大家在以前
think of. And I can tell you that in the
old days, basically, the way you would

79
00:06:19,737 --> 00:06:23,663
定义某物看起来随机的方法
你会说，有好多统计测试
define that something looks random. As
you would say, hey, here's a battery of

80
00:06:23,663 --> 00:06:27,754
所有的方法都说这个字符串是随机的
statistical tests. And all of them said
that this string looks random. Therefore,

81
00:06:27,754 --> 00:06:31,896
那么我们就是这个发生器生成的字符串
是随机的，是个好发生器
we say that this generator that generated
the string is good generator. In other

82
00:06:31,896 --> 00:06:36,091
换句话说，这个定义使用了
一个固定的统计测试的集合
words, this definition, then, uses a fixed
set of statistical tests, is actually not

83
00:06:36,091 --> 00:06:40,364
因此不是安全性的良好定义
对于更一般的密码学而言
a good definition for security, but more
generally, for crytpo. But before we talk

84
00:06:40,364 --> 00:06:45,290
但在我们讨论安全性定义前
我们还需讨论
about actually defining security, the next
thing we talk about is how do we evaluate

85
00:06:45,290 --> 00:06:50,040
如何评估一个统计测试
为此，我们定义优势的概念
whether a statistical test is good or not?
So to do that, we define the concept of

86
00:06:50,040 --> 00:06:54,321
让我定义优势的意思
advantage. And so let me define the
advantage. So here we have a generator

87
00:06:54,321 --> 00:06:59,188
我们有一个生成N位字符串的发生器
我们有N位字符串的统计测试
that outputs N bit strings. And we have a
statistical tests on N bit strings. And we

88
00:06:59,188 --> 00:07:04,578
我们定义这个发生器的优势
记为优势子PRG
define the advantage of this generator,
as denoted by advantage sub PRG,

89
00:07:04,578 --> 00:07:10,313
统计测试A相对于发生器g的优势
the advantage of the statistical test A
relative to the generator g. I'll define

90
00:07:10,313 --> 00:07:16,121
我如下定义优势，定义为两个量的差
it as follows, basically the difference
between two quantities. The first quantity

91
00:07:16,121 --> 00:07:21,679
第一个量是统计测试输出1的可能性
is basically, we ask how likely is this
statistical test to output one. When we

92
00:07:21,679 --> 00:07:27,007
当我们给它一个伪随机字符串
就像这里k是均匀选取的
give it a pseudo random string just like
here K is chosen uniformly from the C

93
00:07:27,007 --> 00:07:32,403
我们关注统计测试输出1的可能性
space we ask how likely is the statistical
test to output one when we give it a

94
00:07:32,403 --> 00:07:37,799
当输入是由发生器生成的伪随机输出
pseudo random output generated by the
generator verses now we ask how likely is

95
00:07:37,799 --> 00:07:43,532
同时我们还要看输入是真随机字符串时
the statistical test to output one when we
give it a truly random string. So here are

96
00:07:43,532 --> 00:07:48,174
那么这里是真随机的n位01字符串
is truly random in zero random one to the
n. Okay, and yeah. We look at the

97
00:07:48,174 --> 00:07:52,447
好的，我们看两个量的差
difference between these two quantities.
Now you realize because these are

98
00:07:52,447 --> 00:07:56,720
因为是概率的差，所以差别应该在
differences of probabilities this
advantage is always going to lie in the

99
00:07:56,720 --> 00:08:00,733
区间[0,1]里。我们来想想
interval zero, one. So let's think a
little bit about what this advantage

100
00:08:00,733 --> 00:08:05,138
这个优势的意思。首先，
如果优势接近于1
actually means. So first of all if the
advantage happens to be close to one. Well

101
00:08:05,138 --> 00:08:09,580
什么意思？当我们输入伪随机数时
what does that mean? That means that
somehow, the statistical test A behaves

102
00:08:09,580 --> 00:08:14,620
和输入真随机数时，统计测试A
表现得完全不同
differently when we gave it pseudo-random
inputs, when we gave it the output of the

103
00:08:14,620 --> 00:08:19,175
对吧？它表现地不一样
generator, for when we gave it truly
random inputs, right? It somehow behaved

104
00:08:19,175 --> 00:08:23,790
一种情况下，它以一定概率输出1
differently. In one case, it output one
with a certain probability. And in the

105
00:08:23,790 --> 00:08:28,344
另一情况下，它以别的概率输出1
other case, it output one with a very
different probability, okay? So somehow,

106
00:08:28,344 --> 00:08:32,778
对吧？它就能表现不同。这样一来
it was able to behave differently. And
what they really means is that the

107
00:08:32,778 --> 00:08:37,211
这个统计测试就能将这个发生器的输出
statistical test could basically
distinguish the output of the generator

108
00:08:37,211 --> 00:08:42,877
和真随机区分开来。好的，某种意义上
我们说这个统计测试
from random. Okay, so in some sense we'll
say that this statistical test broke the

109
00:08:42,877 --> 00:08:47,053
破解了发生器G，因为可以区分
输出序列和真随机序列
generator G because it was able to
distinguish the output from random.

110
00:08:47,053 --> 00:08:51,975
但是如果这个优势跟0很近
什么意思？
However if the advantage is close to zero
Well what does that mean? That means that

111
00:08:51,975 --> 00:08:56,451
这意味着统计测试在两种情况下
表现地基本一致
basically the statistical tests behaves
pretty much the same on pseudo random

112
00:08:56,451 --> 00:09:01,222
对真随机的输入，我们基本上可以说
inputs. As it does on truly random inputs.
And basically there we would say that A

113
00:09:01,222 --> 00:09:05,773
测试A无法区分发生器输出和真随机
could not distinguish the generator from
random. Okay, so this sum gives you a

114
00:09:05,773 --> 00:09:10,289
这个可以给大家一点直观感受
感受优势这一重要概念
little bit of intuition about why this
concept of advantage is important. It

115
00:09:10,289 --> 00:09:15,222
它告诉我们测试A能否破解发生器
basically tells us whether A was able to
break the generator, namely distinguish it

116
00:09:15,222 --> 00:09:19,917
即区分随机性，要不就不能破解之
那么我们再看一个傻傻的例子
from random, or not able to break it. So
let's look, first of all, at a very silly

117
00:09:19,917 --> 00:09:24,671
假设我们有一个统计测试A
它不管输入是什么
example. Suppose we have a statistical
test A that simply ignores its inputs and

118
00:09:24,671 --> 00:09:29,496
总是输出0。好，总是输出0
大家觉得相对于任一发生器G
always outputs zero. Okay. Always output
zero. What do you think of the advantage

119
00:09:29,496 --> 00:09:33,742
所拥有的优势是多少？
of this statistical test relative to a
generator G? So, I hope everybody

120
00:09:33,742 --> 00:09:37,932
我希望大家都能认为优势是0
我解释一下为什么
say the advantage is zero, let
me just explain, why that's the case,

121
00:09:37,932 --> 00:09:41,791
如果在测试中，总是输出0
well, if the statistical test, 
always outputs, zero, that

122
00:09:41,791 --> 00:09:45,982
这意味着，输入伪随机序列时，
它绝不输出1，所以以概率0输出1
means, pseudo random inputs, it will never
output one, so, the probability that

123
00:09:45,982 --> 00:09:50,282
类似地，输入真随机序列时
outputs one, is zero. Similarly, when we
give a truly random input, it still will

124
00:09:50,282 --> 00:09:54,527
它依然不会输出1，其概率还是0
never output one, and, so, the probability
that outputs one, is zero,

125
00:09:54,527 --> 00:09:58,772
所以0减0等于0，故优势为0
and, so, zero minus zero is zero, so, its
advantage is zero, so, basically, and, a

126
00:09:58,772 --> 00:10:03,128
这个测试根本不看输入
显然根本无法区分
statistical test that ignores its, its
input, does not able to distinguish, truly

127
00:10:03,128 --> 00:10:07,441
真随机和伪随机，好
random inputs, from, a pseudo random
input, obviously. Okay, now let's look at

128
00:10:07,441 --> 00:10:12,861
下个例子更有趣点。假设我们的发生器G
a more interesting example. So suppose we
have a generator G that satisfies a funny

129
00:10:12,861 --> 00:10:17,671
满足一个有趣的性质：对三分之二的密钥
property. It so happens that for
two-thirds of the keys, the first bit

130
00:10:17,671 --> 00:10:22,892
发生器输出的第一位是1，怎么样？
of the output of the generator happens to
be one, okay? So if I choose a random key

131
00:10:22,892 --> 00:10:28,176
所以如果我随机选取一个密钥
发生器以2/3的概率，第一位输出为1
with probability two-thirds, the generator
will output one as its first bit, okay? So

132
00:10:28,176 --> 00:10:33,333
好吧？这就是这个发生器的性质
that's the property of the generator that
we're looking at. Now, let's look at the

133
00:10:33,333 --> 00:10:37,790
我们来看下面这个统计测试
这个测试是这样的
following statistical test. The
statistical test basically says, if the

134
00:10:37,790 --> 00:10:42,883
如果字符串最高位是1，就输出1
most signifigant bit of the string you
gave me is one, I'm gonna say one, meaning

135
00:10:42,883 --> 00:10:48,167
任何这是随机的；如果输入的最高位不是1
I think it's random. If the most signigant
bit of the stream you gave me is not one,

136
00:10:48,167 --> 00:10:53,969
是0，那就输出0
给大家的问题是
zero, I'm gonna say zero. Okay
so now my question to you is what is the

137
00:10:53,969 --> 00:10:59,625
这个统计测试对发生器G的优势是多少？
advantage of this statistical test on the
generator G? Okay, so remember I just

138
00:10:59,625 --> 00:11:04,552
好，我记得优势的定义写在这了
大家可以想一想
wrote down the definition here again. And
I'll let you think about this for a

139
00:11:04,552 --> 00:11:09,933
我来解释一下。假设我们对这个统计测试
输入伪随机序列
second. So let me explain. Suppose we give
the statistical tests pseudo random

140
00:11:09,933 --> 00:11:14,568
根据G的定义，我们知道以2/3的概率
inputs. By definition of G, we know that
with probability two-thirds, the first

141
00:11:14,568 --> 00:11:19,625
输入的第一位是1。但如果是以1开头
bits in the inputs will start with the bit
one. But if it starts with a bit one, then

142
00:11:19,625 --> 00:11:24,320
测试结果会是1，换句话说
the statistical test will output one. In
other words, the probability that this

143
00:11:24,320 --> 00:11:29,196
统计测试输出1的概率严格地为2/3
我们再看真随机的情况
statistical test outputs one is exactly
two-thirds. Now let's look at the case of

144
00:11:29,196 --> 00:11:33,831
如果我给一个真随机的字符串
a random string. If I give you a random
string, how likely is it that the most

145
00:11:33,831 --> 00:11:38,346
最高位是1的概率是多少？
对于真正随机的字符串
signifigant bits of the random string is
one? Well, for a random string, that

146
00:11:38,346 --> 00:11:43,342
最高位是1约占一半，这时
统计测试会输出1
happens exactly half the time, and so in
this case the statistical test will output

147
00:11:43,342 --> 00:11:47,918
也就是以1/2的概率，所以总的
优势为1/6
one, with probability one-half. And so the
overall advantage is one-sixth, and

148
00:11:47,918 --> 00:11:52,553
1/6不是一个可忽略的量了
是个相当大的数了
one-sixth is actually a non-negligible
number, that's actually a fairly large

149
00:11:52,553 --> 00:11:57,490
这意味着这个发生器可以区分输出了
number, which basically means that this a
was able to distinguish the output. We'll

150
00:11:57,490 --> 00:12:03,314
我们说A以优势1/6破解了发生器G
say that A breaks the generator G with
advantage 1/6. Okay, which basically

151
00:12:03,314 --> 00:12:08,292
这说明这个发生器不怎么好
被破解了，好
means that this generator is no good, is
broken. Okay, so now that we understand

152
00:12:08,292 --> 00:12:13,521
现在我们理解了统计测试是什么了
现在可以进一步去定义
what statistical tests are, we can go
ahead and define, what is a secure

153
00:12:13,521 --> 00:12:19,191
什么是安全的伪随机数发生器
我们说发生器G是安全的
pseudo-random generator. So, basically, we
say that, as generator G is secure, if

154
00:12:19,191 --> 00:12:24,935
如果不存在有效的统计测试
可以区分发生器G的输出
essentially no efficient, statistical
tests can distinguish its output from

155
00:12:24,935 --> 00:12:30,311
和真随机序列。更精确地
我们说，对所有有效的统计测试
random. More precisely, what we'll say is
that, basically for all efficient

156
00:12:30,311 --> 00:12:36,423
如果我看其优势
statistical tests, a... Statistical tests,
a... It so happens that if I look at the

157
00:12:36,423 --> 00:12:42,496
统计测试E对发生器G的优势
advantage. Of the statistical test E
relative to G. This advantage basically is

158
00:12:42,496 --> 00:12:47,246
基本上这个优势是可忽略的
换句话说，它很接近于0
negligible. So, in other words,
it's very close to zero, and as a result,

159
00:12:47,246 --> 00:12:52,103
这样统计测试不能区分发生器输出
和真随机序列
this, statistical test was not able to
distinguish the output from random, and

160
00:12:52,103 --> 00:12:56,961
这点对所有的统计测试都成立
that has to be true for all statistical
tests. So, this is a very, very pretty and

161
00:12:56,961 --> 00:13:01,211
所以这个定义非常优雅
一个生成器是安全的
elegant definition, that says that a
generator is secure, not only if a

162
00:13:01,211 --> 00:13:06,129
不仅特定的统计测试认为它的输出
是随机的，事实上对所有
particular battery of statistical tests
says that the output looks random, but, in

163
00:13:06,129 --> 00:13:10,929
有效的统计测试，都认为输出是随机的
fact, all efficient statistical tests will
say the output looks random. Okay? One

164
00:13:10,929 --> 00:13:15,992
好吧？我需要指出一点
限制为有效的统计测试是必须的
thing I'd like to point out is, that the
restriction to efficient statistical tests

165
00:13:15,992 --> 00:13:20,934
如果我们不说是有效的
而是看所有可能的统计测试的话
is actually necessary. If we ask that all
statistical tests, regardless of whether

166
00:13:20,934 --> 00:13:25,836
所有统计测试都无法区分输出和真随机
they're efficient or not, not be able to
distinguish the output from random. Then

167
00:13:25,836 --> 00:13:30,469
事实上，这无法被满足
换句话说，如果我们
in fact, that can not be satisfied. So in
other words if we took out the

168
00:13:30,469 --> 00:13:34,826
去掉测试是有效的这一要求
这个定义将无法被满足
requirements that the test be efficient.
Then this definition would be

169
00:13:34,826 --> 00:13:39,484
这点留给大家想一想
unsatisfiable. And I'll leave this as a
simple puzzle for you to think about. But
(提示：有效是说，测试算法总在有限步内
终止并返回结果)

170
00:13:39,484 --> 00:13:43,851
基本上在定义里加上只有有效测试
basically the fact is that restricting
this definition into only efficient

171
00:13:43,851 --> 00:13:48,625
这一限制，就是为了让定义是可满足的
statistical tests is actually necessary
for this to be satisfiable. So now that we

172
00:13:48,625 --> 00:13:53,341
有了定义，下一个问题是
我们能不能构建这么一个发生器
have a definition, the next question is
can we actually construct a generator and

173
00:13:53,341 --> 00:13:57,533
然后证明它是个安全的PRG呢？
换句话说，证明没有一个有效测试
then prove that it is in fact a secure
PRG. In other words, prove that no

174
00:13:57,533 --> 00:14:02,366
可以区分发生器的输出和真随机
efficient statistical test can distinguish
its output from random. And it turns out

175
00:14:02,366 --> 00:14:07,022
事实上，答案是我们不能
就是不知道
that the answer is we actually can't. In
fact, it's not known. If there are any

176
00:14:07,022 --> 00:14:12,627
如果有任何极有可能是安全的PRG
我说，简单的原因在于
probably secure PRG's. Then I will just
say very briefly the reason is that if you

177
00:14:12,627 --> 00:14:18,301
如果你能证明一个特定的发生器是安全的
那就意味着
could prove that a particular generator is
secure that would actually imply that P

178
00:14:18,301 --> 00:14:23,455
P不等于NP，我还不想纠结在这
is not equal to NP. And I don't want to
dwell on this. Because I don't want to

179
00:14:23,455 --> 00:14:28,706
因为可能大家有些不知道P和NP
那我就告诉大家如果P=NP
assume that you guys know what P and NP
are. But I'll tell you as a simple fact

180
00:14:28,706 --> 00:14:33,420
会发生什么。那样的话
很容易证明不存在安全的PRG
that in fact in P is equal to NP. Then
it's very easy to show that there are no

181
00:14:33,420 --> 00:14:37,858
所以如果你能给我证明一个PRG是安全的
secure PRGs. And so if you could prove to
me that a particular PRG is secure, that

182
00:14:37,858 --> 00:14:41,913
那也就意味着P不等于NP
would imply that P is not equal to
NP. Again, I will leave this to

183
00:14:41,913 --> 00:14:45,858
这点也留给大家想想
you as a simple puzzle to think about.
But, even though we can't actually
(提示：逆否命题)

184
00:14:45,858 --> 00:14:50,297
尽管我们不能严格地证明某个PRG
是安全的，我们还是有
rigorously prove that a particular PRG is
secure, we still have lots and lots and

185
00:14:50,297 --> 00:14:54,406
大量的PRG候选方案，之前看过一些
lots of heuristic candidates, and we even
saw some of those in the previous

186
00:14:54,406 --> 00:14:59,289
好，现在我们理解了什么是安全PRG
segments. Okay now that we understand what
is a secure PRG. I want to talk a little

187
00:14:59,289 --> 00:15:03,558
我想谈一下这个定义的
一些应用和影响
bit about some applications and
implications of this definition. And so

188
00:15:03,558 --> 00:15:08,308
第一个，事实上安全的PRG
the first thing I want to show you is that
in fact a secure PRG is necessarily

189
00:15:08,308 --> 00:15:12,884
是不可预测的，前面几节
我们讨论了发生器不可预测的意思
unpredictable. In a previous segment, we
talked about what it means for a generator

190
00:15:12,884 --> 00:15:17,114
我们说，这个的意思是
to be unpredictable. And we said that,
basically, what that means is that, given

191
00:15:17,114 --> 00:15:21,508
给定发生器输出的前缀
是不可能预测出输出的下一位是什么
a prefix of the output generator, it's
impossible to predict the next bit of the

192
00:15:21,508 --> 00:15:25,902
好，所以我们想展示一个发生器是否安全
output. Okay, so we'd like to show that if
a generator is secure, then necessarily,

193
00:15:25,902 --> 00:15:30,176
必须意味着它是不可预测的
所以我们唯一的方法是
it means it's unpredictable. And so the
only way we're gonna do that is using the

194
00:15:30,176 --> 00:15:34,254
使用逆否命题，也就是，我们说
如果你给出一个可预测的发生器
contrapositive. That is, we're gonna say
that if you give me a generator that is

195
00:15:34,254 --> 00:15:37,971
那么这就意味着它是不安全的
predictable, then necessarily, it's
insecure. In other words, necessarily, I

196
00:15:37,971 --> 00:15:42,050
换句话说，我能把它从真随机中区分出来
这是个很简单的事实
can distinguish it from random. And so
let's see, this is actually a very simple

197
00:15:42,050 --> 00:15:46,077
那我们看看怎么用这个事实
假设你给出了一个预测算法
fact. And so let's see how we would do
that. So suppose you give me a predictor.

198
00:15:46,077 --> 00:15:50,000
换句话说，假设你有一个有效算法
In other words, suppose you give me an
efficient algorithm, such that, in fact,

199
00:15:50,000 --> 00:15:54,234
如果我把发生器的输出作为其输入
if I give this algorithm the output of the
generator, but I give it only the first

200
00:15:54,234 --> 00:15:58,599
只给前I位，该算法可以预测输出的下一位
I-bits of the outputs. It's able to
predict the next bit of the output. In

201
00:15:58,599 --> 00:16:03,664
换句话说，给定前I位
可以预测第I+1位
other words given the first I-bit it's
able to predict the I plus first bit. And

202
00:16:03,664 --> 00:16:08,827
以特定的概率。比如说我们取随机密钥k
it does that with a certain probability.
So let's say if we choose a random k. From

203
00:16:08,827 --> 00:16:13,367
从密钥空间中。然后，预测机可以
the keyspace. Then, clearly, a done 
predictor would be able to predict the

204
00:16:13,367 --> 00:16:18,138
以1/2概率预测下一位，简单猜测
next bit with probability one-half, simply
just guess the bits. You'll be right with

205
00:16:18,138 --> 00:16:22,391
也可以做到1/2概率成功预测
但是这个算法A可以预测下一位
probability one-half. However, this
algorithm A is able to predict the next

206
00:16:22,391 --> 00:16:27,053
以1/2加Epsilon的概率，是这样界定的
bit with probability half with epsilon. So
it's bound to the way. From a half. And,

207
00:16:27,053 --> 00:16:31,726
事实上，我们要求这对某些不可忽略的
Epsilon成立，例如
in fact, we require that this by true for
some non negligible epsilon. So, for

208
00:16:31,726 --> 00:16:36,338
Epsilon为千分之一，这就是个
很危险的预测算法了
example, epsilon =1/1000 would already be a
dangerous predictor, because it can

209
00:16:36,338 --> 00:16:40,949
因为它可以预测下一位，给定前缀
以一个不可忽略的优势
predict the next bits, given a prefix,
with non negligible advantage. Okay, so

210
00:16:40,949 --> 00:16:45,533
好，设想我们有一个算法
我们可以使用这个算法破解发生器
suppose we have such an algorithm. Let's
see that we can use this algorithm to

211
00:16:45,533 --> 00:16:50,010
换句话说，可以区分这个发生器的输出
break our generator. In other words to
show that a generator is distinguishable

212
00:16:50,010 --> 00:16:54,146
和真随机，这个发生器是不安全的
所以我们将定义一个统计测试
from random and therefore, is insecure. So
what we'll do is we'll define a

213
00:16:54,146 --> 00:16:59,463
那么我们如下定义统计测试B
statistical test. So, let's define the
statistical test B as follows. Basically,

214
00:16:59,463 --> 00:17:04,979
给定字符串x，B在前I位上运行算法A
B, given a string, x, what it will do, is
it will simply run algorithm A on the

215
00:17:04,979 --> 00:17:10,711
然后统计测试简单地问一下
first I-bit of the string x that it was
given. And, statistical test b is simply

216
00:17:10,711 --> 00:17:16,662
算法A是否成功地预测了第I+1位？
gonna ask, was a successful in predicting
the I-plus first bit of the string? If it

217
00:17:16,662 --> 00:17:22,579
如果成功了，返回1
如果不成功，返回0
was successful, then it's gonna output
one. And if it wasn't successful, then

218
00:17:22,579 --> 00:17:28,154
好，这就是我们的统计测试
我们把它放在一个盒子里
it's gonna output zero. Okay. This our
statistical task. Let's put it in a box.

219
00:17:28,154 --> 00:17:33,407
那么我们可以随时使用他
对任意N位字符串
So we can take it wherever we like. And we
can run the statistical test on any N bit

220
00:17:33,407 --> 00:17:38,466
我们都可以运行这个统计测试
现在，我们看会发生什么
string that's given to us as inputs. So
now, let's look at what happens. Suppose

221
00:17:38,466 --> 00:17:43,524
假设我们给这个统计测试输入
真随机的字符串，也就是R
we give the statistical test, a truly
random string. So a truly random string R.

222
00:17:43,524 --> 00:17:48,583
我们问，统计测试输出1的概率是多少？
And we ask, what is the probability that
the statistical test outputs one? Well,

223
00:17:51,112 --> 00:17:53,642
因为是真随机字符串，I+1位
与前面I位是完全独立的
for a truly random string, the I+1
bit is totally independent of the first

224
00:17:53,642 --> 00:17:58,765
所以算法A的输出
I-bits. So whatever this algorithm is
gonna output is completely independent of

225
00:17:58,765 --> 00:18:04,231
也与字符串R的第I+1位完全独立
所以不管A输出什么
what's, I+1 bit of the string R is.
And so whatever A outputs the probability

226
00:18:07,162 --> 00:18:10,092
输出与第I+1位独立
is going to be equal to some random 
bit X I+1. Random independent bit X I+1, that

227
00:18:10,092 --> 00:18:14,754
概率为1/2。换句话说，算法A
probability is exactly 1/2. In other
words, algorithm a simply has no

228
00:18:14,754 --> 00:18:19,620
不提供第I+1位的任何信息
information about what the bit X I+1 
is, and so necessarily, the probability is

229
00:18:19,620 --> 00:18:24,254
故成功预测I+1位的概率为1/2
另一方面，我们看一下
able to predict X I+1 is exactly 
one half. On the other hand, let's look at

230
00:18:24,254 --> 00:18:28,946
当我们给统计测试一段伪随机序列时
what happens when we give our statistical
tests a pseudo-random sequence, okay. So

231
00:18:28,946 --> 00:18:33,521
我们对发生器的输出进行统计测试B
now we're going to run the statistical
test on the output of the generator, and

232
00:18:33,521 --> 00:18:37,866
我们问，测试输出1的可能性是多大？
根据算法A的定义
we ask how likely is it to output one.
Well, by definition of A, we know that

233
00:18:37,866 --> 00:18:42,326
当我们给定发生器输出的前I位时
when we give it the first I bits of the
output of the generator, it's able to

234
00:18:42,326 --> 00:18:46,851
算法A成功预测下一位的概率是1/2
加上Epsilon
predict the next bit with probability 
1/2 + epislon. So in this case our

235
00:18:46,851 --> 00:18:51,657
这时我们的统计测试B会
以大于1/2+Epsilon的概率输出1
statistical test B will output one with
probability greater than 1/2 + epsilon

236
00:18:51,657 --> 00:18:57,700
这个的意思是，如果我们看
And basically what this means, 
is if we look at the advantage of our

237
00:18:57,700 --> 00:19:04,207
我们统计测试对发生器G的优势
也就是这两个量之间的差距
statistical tests over the generator G
it's basically, the difference between

238
00:19:04,207 --> 00:19:09,648
两者有差别
this quantity and that quantity. There's a
difference between the two. You can see

239
00:19:09,648 --> 00:19:14,514
容易看出，它比Epsilon大
这意味着，如果算法A
that it's clearly greater than an epsilon.
So what this means is that if algorithm A

240
00:19:14,514 --> 00:19:18,917
可以以优势Epsilon预测下一位
is able to predict the next bits with
advantage epsilon, then algorithm B is

241
00:19:18,917 --> 00:19:23,533
那么测试算法B可以以优势Epsilon
区分出发生器的输出序列，对吧？
able to distinguish the output of the
generator with advantage epsilon. Okay? So

242
00:19:23,533 --> 00:19:28,696
如果A是个好的预测算法，B是个
好的统计测试，可以破解发生器
if A is a good predictor, B is a good
statistical test that break the generator.

243
00:19:28,696 --> 00:19:33,859
我们说这个逆否命题是说
如果发生器G安全
And as we said, the counter-positive of
that is that if G is a secure generator,

244
00:19:33,859 --> 00:19:38,960
没有任何好的统计测试
也就没有任何好的预测算法
then there are no good statistical tests.
And as a result, there are no predictors.

245
00:19:38,960 --> 00:19:43,756
对吧？这也就意味着
这个发生器是不可预测的
Okay? Which means that the generator is,
as we said, unpredictable. Okay, so, so

246
00:19:43,756 --> 00:19:48,361
好，目前我们知道，如果发生器是安全的
far, what we've seen is that if the
generator is secure, necessarily, it's

247
00:19:48,361 --> 00:19:53,030
给定前I位，也不可能预测第I+1位
impossible to predict the I+1 bit,
given first I bits.

248
00:19:53,030 --> 00:19:57,890
1982年姚期智给出了一个优雅重要的定理
Now there's a very elegant and remarkable
theorem Yao back in 1982. They
(1982年论文Theory and application 
of trapdoor functions，用熵的观点证明)

249
00:19:57,890 --> 00:20:02,623
事实上，逆命题也成立，换句话说
chose it, in fact the converse is also
true. In other words, if I give you a

250
00:20:02,623 --> 00:20:07,675
如果我给大家的发生器是不可预测的
不可由前I位预测第I+1位
generator that's unpredictable, so you
cannot predict the I+1 bits from the

251
00:20:07,675 --> 00:20:12,453
对任意I都成立，那么这个发生器
事实上就是安全的
first I bits, and that's true for all I.
That generator, in fact, is secure. Okay,

252
00:20:12,453 --> 00:20:17,021
好，我把这个定理说的更清楚点
so let me state the theorem a little bit
more precicely. So here we have our

253
00:20:17,021 --> 00:20:21,949
这里我们的发生器输出n位字符串
这个定理告诉我们
generator that outputs n bit outputs. The
theorem says the following, basically for

254
00:20:21,949 --> 00:20:26,517
对任何位置I，不可能根据前I位
预测输出的第I+1位
all bit positions, it's impossible to
predict I+1 bit of the output

255
00:20:26,517 --> 00:20:30,905
这对任何I都成立，换句话说
given the first I bit. And that's true for
all I. In other words, again, the

256
00:20:30,905 --> 00:20:35,181
这个发生器对所有位置都不可预测
那么事实上这意味着
generator is unpredictable for all bit
positions. Then, that, in fact, implies

257
00:20:35,181 --> 00:20:38,969
这个PRG就是安全的
我还想用应用重新组织下语言
that the generator is a secure PRG.
I want paraphrase this in English,

258
00:20:39,123 --> 00:20:43,321
这个结果解读为，这些下一位预测算法
and so the way to kinda interpret this
result is to say that it's basically these

259
00:20:43,321 --> 00:20:47,570
这些预测算法试图预测第I+1位
next bit predictors. These predictors that
try to predict the I+1 bit given the

260
00:20:47,570 --> 00:20:51,410
给定前I+1位。如果它们不能把G的输出
和真随机区分开来
first I bits. If they're not able to
distinguish G from random, then, in fact,

261
00:20:51,410 --> 00:20:55,125
那么事实上，就没有统计测试可以
区分G和真随机
no statistical test is going to
distinguish G from random. So kind of next

262
00:20:55,125 --> 00:20:58,804
这些下一位预测算法某种意义上
是泛指的预测算法
bit predictors are in some sense
universal, predictors, when it comes to

263
00:20:58,804 --> 00:21:02,334
当它用来区分随机性时
顺带一说，这个定理不难证明
distinguishing things from random. This
theorem, by the way, it's not too

264
00:21:02,334 --> 00:21:06,113
证明有一个很优雅的思路
difficult to prove, but there's a very
elegant idea behind its proof. I'm not

265
00:21:06,113 --> 00:21:10,090
我不给出具体证明，我鼓励
大家自己想想
gonna do the proof here, but I encourage
you to think about this as a puzzle, try

266
00:21:10,090 --> 00:21:14,017
试图自己证明之
我们看一下这个定理的影响
to kind of try to prove this theorem
yourself. Let me show you kind of one cute

267
00:21:14,017 --> 00:21:19,101
我问下面这个问题
implication of this theorem. So let me ask
you the following question. Suppose I give

268
00:21:19,101 --> 00:21:24,417
假设我给大家一个发生器，告诉大家
给定输出的最后一位
you a generator and I tell you that given
the last bit of the output. It's easy to

269
00:21:24,417 --> 00:21:28,963
容易预测输出的第一位，对吧？
那么给最后一位
predict the first bit of the outputs,
okay? So given the last end bits, you can

270
00:21:28,963 --> 00:21:33,627
你可以计算出第一位
这和可预测正好相反，对吧？
compute the first end bits. That's kind of
the opposite of predictability, right?

271
00:21:33,627 --> 00:21:38,469
可预测是说给第一位，
你可以算出下一位
Predictability mean given the first
bit, you can produce the next bits. Here,

272
00:21:38,469 --> 00:21:43,133
这里是给最后一位，你可以算出第一位
我给大家的问题是
given the last bits, you can produce the
first ones. And my question to you, does

273
00:21:43,133 --> 00:21:47,266
这是否意味着这个发生器是可预测的？
that mean that the generator is
predictable? Can you somehow, from this

274
00:21:47,266 --> 00:21:52,310
能否根据这点，为这个发生器
构造一个预测算法呢？
fact, still build a predictor for this
generator? This is kind of a simple

275
00:21:52,310 --> 00:21:56,898
这是姚定理的一个简单应用
答案是可以，我解释一下
application of Yao theorem. let me explain to
you the answer is actually yes let me

276
00:21:56,898 --> 00:22:02,074
如何构造这个预测算法
实际上我不用构造之
explain why how do we build this generator
well, actually we're not going to build it

277
00:22:02,074 --> 00:22:06,661
我证明它存在即可
I'm going to show you that the generator
exists. Well because an over two bits
(口误generator，应为predictor)

278
00:22:06,661 --> 00:22:11,661
首先，超过两字节不意味着这个发生器
first an over two bits doesn't necessarily
mean that the generator. Here let me write

279
00:22:11,661 --> 00:22:16,613
我这样写，意思是g不安全
因为如之前所说
them this way what it means is that g is
not secure. Because just as we did before

280
00:22:16,613 --> 00:22:22,043
容易构造一个统计测试来区分G的输出
和均匀分布的序列
it's very easy to build a statistical test
that will distinguish the output of G from

281
00:22:22,043 --> 00:22:27,156
但如果G不安全，根据姚定理
uniform. So G is not secure. But if G Is not
secure, by Yao's Theorem, that means that

282
00:22:27,156 --> 00:22:32,396
意味着G是可预测的，换句话说
存在某个位置I，给定输出前I位
G is predectible. So in other words, there
exists some I for which given the first I

283
00:22:32,396 --> 00:22:37,257
你能预测出第I+1位，好
bits of the output, you can build 
the I+1 bits of the output. Okay, so

284
00:22:37,257 --> 00:22:42,371
即使我不能为大家构造预测算法
我们知道这个预测一定存在
even though I can't quite point to you a
predictor, we know that a predictor must

285
00:22:42,371 --> 00:22:46,529
这就是姚定理的一个可爱的应用
exist. So that's a one cute simple
application of Yao theorem. Now before we

286
00:22:46,693 --> 00:22:50,856
现在在我们结束本节前
对我们所做的进行一点推广
end the segment I want to kind of,
generalize a little bit of what we did.

287
00:22:50,856 --> 00:22:54,964
引入一些将来会很有用的记号
And introduce a little bit of important
notation that's going to be useful

288
00:22:54,964 --> 00:22:58,516
那么我们推广
actually throughout. So, we're gonna
generalize the concept of

289
00:22:58,516 --> 00:23:02,889
与均匀分布不可区分的概念
到两个一般分布间的不可区分
indistinguishability from uniform, to
indistinguishability of two general

290
00:23:02,889 --> 00:23:07,143
设想我给出分布p1和p2，我问
distributions. So, suppose I give you p1
and p2, and we ask, can these two

291
00:23:07,143 --> 00:23:11,636
这两个分布可区分吗？
我们说这些分布
distributions be distinguished? And so
we'll say that the distributions are

292
00:23:11,636 --> 00:23:16,602
计算上不可区分，记为p1波浪线p2
computationally indistinguishable, and
we'll denote this by p1, a squiggly p. P2.

293
00:23:16,602 --> 00:23:22,908
这意味着在多项式时间里
p1无法与p2相区分
This means that, in polynomial time, P1
cannot be distinguished from P2. And we'll

294
00:23:22,908 --> 00:23:28,582
我们说它们是不可区分的，与之前一样
say that they're indistinguishable,
basically, just as before

295
00:23:28,582 --> 00:23:35,759
对所有有效的统计测试A
if basically for all, efficient, statistical
tests, statistical tests A, it so happens

296
00:23:35,759 --> 00:23:44,160
如果我从分布p1里取样，将结果
交由A进行测试
that if I sample from the distribution P1.
And I give the output to A. Versus if I

297
00:23:44,160 --> 00:23:51,208
作为对比，我从p2中取样，也交给A
sample from the distribution P2, and I
give the sample to A. Then basically A

298
00:23:51,208 --> 00:23:55,414
那么基本上A对两种情况表现一致
换句话说，两概率的差别
behaves the same in both cases. In
other words, the difference between these

299
00:23:55,414 --> 00:23:59,893
是可忽略的。这个对所有统计测试都成立
two probabilities is negligible. And this
has to be true for all statistical tests.

300
00:23:59,893 --> 00:24:04,577
对所有统计测试，对吧？
如果是这种情况，我们说
For all efficient statistical tests. Okay?
So if this is the case then we say that,

301
00:24:04,577 --> 00:24:09,530
A无法区分，它区分两分布的优势
well A couldn't distinguish. Its advantage
in distinguishing two distributions is

302
00:24:09,530 --> 00:24:14,240
是可忽略的，如果这点对所有
有效的统计测试都成立
negligible and if that's true for all
efficient statistical tests then we say

303
00:24:14,240 --> 00:24:18,649
我们说，这两个分布是计算上
不可区分的
that the distributions are basically
computationaly indistinguishable,

304
00:24:18,649 --> 00:24:23,481
因为一个有效算法不能区分它们
because an efficient algorithm cannot
distinguish them. And just to show you how

305
00:24:23,481 --> 00:24:28,372
告诉大家这个记号很有用
使用它来表述安全PRG的定义
useful this notation is, basically using
this notation the definition of security

306
00:24:28,372 --> 00:24:32,810
如果我给出一个伪随机分布
for PRG just says. That if I give you a
pseudo-random distribution. In other

307
00:24:32,810 --> 00:24:37,159
换句话说，我随机选取密钥K
输出相应的G
words, I choose K at random, and that
outputs a G of K. That distribution is

308
00:24:37,159 --> 00:24:41,978
这个分布与均匀分布是计算上不可区分的
computationally indistinguishable from the
uniform distribution. So you can see this,

309
00:24:41,978 --> 00:24:46,269
可以看到，这个非常简单的记号
抓住了伪随机数发生器的整个定义
this very simple notation captures the
whole definition of pseudo-random

310
00:24:46,269 --> 00:24:50,795
好，我们后面会用到这个记号
generators. Okay, so we're gonna make use
of this notation. In the next segment,

311
00:24:50,795 --> 00:24:54,439
下一节我们定义密码的安全
when we define, what does it mean for a
cipher to be secure.
